<!DOCTYPE html>
<html>
<head>
    <title>Doom Fishing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: none;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 10px auto;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #555;
            background-color: #000;
            border-radius: 10px;
        }

        #score {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #ff0000;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #ammo {
            font-size: 1.2rem;
            margin: 5px 0;
            color: #ff9900;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #gameOver {
            display: none;
            color: #ff0000;
            font-size: 2rem;
            text-shadow: 3px 3px 0px #000;
            margin: 10px 0;
            text-align: center;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin: 20px auto;
        }

        .control-btn {
            padding: 15px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #8b0000;
            color: white;
            border: 2px solid #ff0000;
            border-radius: 10px;
            touch-action: manipulation;
        }

        #shootBtn {
            grid-column: 2;
            background-color: #ff0000;
        }

        #resetBtn {
            grid-column: 1 / span 3;
            background-color: #4CAF50;
        }

        #forwardBtn {
            grid-column: 2;
            grid-row: 1;
        }

        #backwardBtn {
            grid-column: 2;
            grid-row: 3;
        }

        #leftBtn {
            grid-column: 1;
            grid-row: 2;
        }

        #rightBtn {
            grid-column: 3;
            grid-row: 2;
        }

        #shootBtn {
            grid-column: 2;
            grid-row: 2;
        }

        @media (max-width: 600px) {
            .control-btn {
                padding: 12px;
                font-size: 1rem;
            }
        }

        /* Add weapon selection UI */
        #weaponSelector {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .weapon-btn {
            padding: 5px 10px;
            margin: 0 5px;
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
        }
        
        .weapon-btn.active {
            background-color: #ff0000;
            border-color: #ff6666;
        }
        
        /* Add health bar */
        #healthBar {
            width: 100%;
            max-width: 300px;
            height: 20px;
            background-color: #333;
            margin: 10px auto;
            border: 2px solid #666;
        }
        
        #healthFill {
            height: 100%;
            background-color: #ff0000;
            width: 100%;
        }
        
        /* Add ammo display */
        #ammoDisplay {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        .ammo-type {
            margin: 0 10px;
            color: #ff9900;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="ammo">Health: 100</div>
    <div id="gameOver">Game Over! The fish have taken over the lake!</div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="controls">
        <button class="control-btn" id="forwardBtn">‚Üë</button>
        <button class="control-btn" id="leftBtn">‚Üê</button>
        <button class="control-btn" id="shootBtn">üé£</button>
        <button class="control-btn" id="rightBtn">‚Üí</button>
        <button class="control-btn" id="backwardBtn">‚Üì</button>
        <button class="control-btn" id="resetBtn">New Game</button>
        <button class="control-btn" id="toggleViewBtn" style="background-color: #9c27b0;">Toggle View</button>
        <button class="control-btn" id="spawnFishBtn" style="background-color: #2196F3;">Spawn Fish</button>
        <button class="control-btn" id="debugBtn" style="background-color: #673AB7;">Debug</button>
        <button class="control-btn" id="directHitBtn" style="background-color: #E91E63;">Direct Hit</button>
    </div>

    <div id="healthBar"><div id="healthFill"></div></div>
    <div id="ammoDisplay">
        <div class="ammo-type">BULLETS: <span id="bulletAmmo">50</span></div>
        <div class="ammo-type">SHELLS: <span id="shellAmmo">0</span></div>
        <div class="ammo-type">CELLS: <span id="cellAmmo">0</span></div>
    </div>

    <div id="weaponSelector">
        <button class="weapon-btn active" data-weapon="pistol">PISTOL</button>
        <button class="weapon-btn" data-weapon="shotgun">SHOTGUN</button>
        <button class="weapon-btn" data-weapon="chaingun">CHAINGUN</button>
        <button class="weapon-btn" data-weapon="plasma">PLASMA</button>
        <button class="weapon-btn" data-weapon="bfg">BFG</button>
    </div>

    <audio id="splashSound" src="https://assets.mixkit.co/sfx/preview/mixkit-water-splash-1295.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>

    <script>
        console.log("Script starting...");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameInterval;
        
        // Game state
        let player = {
            x: 2,
            y: 2,
            angle: 0,
            fov: 60 * Math.PI / 180
        };
        
        // Fish types with properties
        const FISH_TYPES = {
            'bluegill': { color: '#4169E1', speed: 0.03, health: 1, damage: 1, points: 10 },
            'bass': { color: '#006400', speed: 0.02, health: 2, damage: 2, points: 20 },
            'pike': { color: '#8B4513', speed: 0.04, health: 1, damage: 3, points: 15 },
            'muskie': { color: '#DC143C', speed: 0.01, health: 4, damage: 5, points: 30 }
        };
        
        // Map definition (1 = wall, 0 = empty)
        const MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        
        // Game state
        let gameState = {
            player: {
                x: 2,
                y: 2,
                angle: 0,
                lures: 10,
                lure_power: 1.0,
                lure_speed: 1.0,
                power_ups: []
            },
            fish: [],
            score: 0,
            game_over: false,
            power_ups: []
        };

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = (containerWidth * 0.75) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function castRay(angle) {
            try {
                // Ray casting algorithm to find walls
                const rayDirX = Math.cos(angle);
                const rayDirY = Math.sin(angle);
                
                let mapX = Math.floor(gameState.player.x);
                let mapY = Math.floor(gameState.player.y);
                
                // Calculate distance to next x or y grid line
                let deltaDistX = Math.abs(1 / (rayDirX || 0.00001));
                let deltaDistY = Math.abs(1 / (rayDirY || 0.00001));
                
                let stepX, stepY;
                let sideDistX, sideDistY;
                
                // Calculate step and initial sideDist
                if (rayDirX < 0) {
                    stepX = -1;
                    sideDistX = (gameState.player.x - mapX) * deltaDistX;
                } else {
                    stepX = 1;
                    sideDistX = (mapX + 1.0 - gameState.player.x) * deltaDistX;
                }
                
                if (rayDirY < 0) {
                    stepY = -1;
                    sideDistY = (gameState.player.y - mapY) * deltaDistY;
                } else {
                    stepY = 1;
                    sideDistY = (mapY + 1.0 - gameState.player.y) * deltaDistY;
                }
                
                // Perform DDA
                let hit = 0;
                let side = 0;
                let maxDistance = 20; // Maximum ray distance
                let distance = 0;
                
                while (hit === 0 && distance < maxDistance) {
                    // Jump to next map square
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        side = 0;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        side = 1;
                    }
                    
                    distance += 1;
                    
                    // Check if ray has hit a wall
                    if (mapY < 0 || mapX < 0 || mapY >= MAP.length || mapX >= MAP[0].length) {
                        hit = 1; // Hit map boundary
                    } else if (MAP[mapY][mapX] > 0) {
                        hit = 1; // Hit wall
                    }
                }
                
                // Calculate distance projected on camera direction
                let perpWallDist;
                if (side === 0) {
                    perpWallDist = (mapX - gameState.player.x + (1 - stepX) / 2) / rayDirX;
                } else {
                    perpWallDist = (mapY - gameState.player.y + (1 - stepY) / 2) / rayDirY;
                }
                
                // Ensure we don't return infinity or NaN
                perpWallDist = Math.max(0.1, perpWallDist || 0.1);
                
                return {
                    distance: perpWallDist,
                    side: side,
                    mapX: mapX,
                    mapY: mapY,
                    stepX: stepX,
                    stepY: stepY
                };
            } catch (error) {
                console.error("Error in castRay:", error);
                // Return a default value to prevent crashes
                return {
                    distance: 5,
                    side: 0,
                    mapX: 0,
                    mapY: 0,
                    stepX: 1,
                    stepY: 1
                };
            }
        }

        function drawWalls() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Draw sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height/2);
            skyGradient.addColorStop(0, "#4a0000");  // Dark red for Doom-like sky
            skyGradient.addColorStop(1, "#700000");  // Lighter red
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height/2);
            
            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, height/2, 0, height);
            groundGradient.addColorStop(0, "#302020");  // Dark brown
            groundGradient.addColorStop(1, "#201010");  // Darker brown
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, height/2, width, height/2);
            
            // Draw walls
            const numRays = width;
            const rayWidth = width / numRays;
            
            for (let x = 0; x < numRays; x++) {
                // Calculate ray angle
                const rayAngle = gameState.player.angle - player.fov/2 + (x / numRays) * player.fov;
                
                // Cast ray
                const result = castRay(rayAngle);
                
                if (!result) continue;
                
                // Calculate wall height
                const wallDist = result.distance;
                const wallHeight = Math.min(height, height / wallDist * 2);
                
                // Draw wall
                const wallY = (height - wallHeight) / 2;
                
                // Determine wall texture based on wall type
                let wallTexture;
                const wallType = MAP[result.mapY][result.mapX];
                
                // Default to stone texture if textures aren't loaded yet
                if (!textures.walls.stone.complete) {
                    // Fallback to colored walls
                    let wallColor;
                    if (result.side === 0) {
                        wallColor = result.stepX > 0 ? "#AA0000" : "#880000"; // Red for X walls
                    } else {
                        wallColor = result.stepY > 0 ? "#770000" : "#550000"; // Darker red for Y walls
                    }
                    
                    ctx.fillStyle = wallColor;
                    ctx.fillRect(x * rayWidth, wallY, rayWidth + 1, wallHeight);
                    continue;
                }
                
                // Choose texture based on wall type
                switch(wallType) {
                    case 1: wallTexture = textures.walls.stone; break;
                    case 2: wallTexture = textures.walls.tech; break;
                    case 3: wallTexture = textures.walls.slime; break;
                    case 4: wallTexture = textures.walls.blood; break;
                    case 5: wallTexture = textures.walls.metal; break;
                    default: wallTexture = textures.walls.stone;
                }
                
                // Calculate texture coordinates
                let textureX;
                if (result.side === 0) {
                    textureX = (gameState.player.y + wallDist * Math.sin(rayAngle)) % 1;
                } else {
                    textureX = (gameState.player.x + wallDist * Math.cos(rayAngle)) % 1;
                }
                
                // Flip texture X if needed
                if ((result.side === 0 && Math.cos(rayAngle) < 0) || 
                    (result.side === 1 && Math.sin(rayAngle) < 0)) {
                    textureX = 1 - textureX;
                }
                
                // Scale texture X to pixel coordinates
                textureX = Math.floor(textureX * wallTexture.width);
                
                // Draw textured wall slice
                try {
                    ctx.drawImage(
                        wallTexture,
                        textureX, 0,
                        1, wallTexture.height,
                        x * rayWidth, wallY,
                        rayWidth + 1, wallHeight
                    );
                    
                    // Add shading based on distance and side
                    let shade = 1.0 - (wallDist / 15);
                    shade *= (result.side === 1) ? 0.7 : 1.0;  // Darker for Y-side walls
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${1 - shade})`;
                    ctx.fillRect(x * rayWidth, wallY, rayWidth + 1, wallHeight);
                } catch (e) {
                    // Fallback if texture drawing fails
                    ctx.fillStyle = "#550000";
                    ctx.fillRect(x * rayWidth, wallY, rayWidth + 1, wallHeight);
                }
            }
        }

        function drawFish() {
            if (!gameState.fish || gameState.fish.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Sort fish by distance (furthest first for proper rendering)
            gameState.fish.sort((a, b) => {
                const distA = Math.pow(a.x - gameState.player.x, 2) + Math.pow(a.y - gameState.player.y, 2);
                const distB = Math.pow(b.x - gameState.player.x, 2) + Math.pow(b.y - gameState.player.y, 2);
                return distB - distA;
            });
            
            // Draw each fish as a Doom-like sprite
            gameState.fish.forEach(fish => {
                // Calculate fish position relative to player
                const dx = fish.x - gameState.player.x;
                const dy = fish.y - gameState.player.y;
                
                // Calculate angle to fish
                let fishAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (fishAngle - gameState.player.angle > Math.PI) fishAngle -= 2 * Math.PI;
                while (fishAngle - gameState.player.angle < -Math.PI) fishAngle += 2 * Math.PI;
                
                // Calculate fish distance
                const fishDist = Math.sqrt(dx * dx + dy * dy);
                
                // Play sound occasionally for nearby enemies
                if (fishDist < 10 && Math.random() < 0.01) {
                    const splashSound = document.getElementById('splashSound');
                    splashSound.volume = Math.min(1.0, 8 / fishDist) * 0.4;
                    splashSound.currentTime = 0;
                    splashSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Check if fish is in field of view
                if (Math.abs(fishAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate fish size based on distance
                    const fishSize = Math.min(height / 1.5, 10000 / fishDist);
                    
                    // Calculate screen position
                    const angleToCenter = fishAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Calculate vertical position based on distance
                    const screenY = height / 2;
                    
                    // Get the appropriate sprite
                    const fishSprite = textures.sprites[fish.type];
                    
                    // Check if sprite is loaded
                    if (fishSprite && fishSprite.complete) {
                        // Draw sprite with scaling based on distance
                        const spriteWidth = fishSize;
                        const spriteHeight = fishSize * (fishSprite.height / fishSprite.width);
                        
                        ctx.save();
                        
                        // Add a shadow
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(screenX, height / 2 + fishSize/2, fishSize / 3, fishSize / 6, 0, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw the sprite
                        ctx.drawImage(
                            fishSprite,
                            screenX - spriteWidth / 2,
                            screenY - spriteHeight / 2,
                            spriteWidth,
                            spriteHeight
                        );
                        
                        // Add health bar
                        const healthPercent = fish.health / FISH_TYPES[fish.type].health;
                        const barWidth = fishSize * 0.8;
                        const barHeight = fishSize / 15;
                        
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(screenX - barWidth/2, screenY - spriteHeight/2 - barHeight*2, barWidth, barHeight);
                        
                        ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                        ctx.fillRect(screenX - barWidth/2, screenY - spriteHeight/2 - barHeight*2, barWidth * healthPercent, barHeight);
                        
                        ctx.restore();
                    } else {
                        // Fallback to colored circles if sprites aren't loaded
                        ctx.save();
                        
                        // Add glow effect for better visibility
                        ctx.shadowColor = FISH_TYPES[fish.type].color;
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = FISH_TYPES[fish.type].color;
                        
                        // Draw fish body
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, fishSize / 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Add health bar
                        const healthPercent = fish.health / FISH_TYPES[fish.type].health;
                        const barWidth = fishSize * 0.8;
                        const barHeight = fishSize / 15;
                        
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(screenX - barWidth/2, screenY - fishSize/2 - barHeight*2, barWidth, barHeight);
                        
                        ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                        ctx.fillRect(screenX - barWidth/2, screenY - fishSize/2 - barHeight*2, barWidth * healthPercent, barHeight);
                        
                        ctx.restore();
                    }
                }
            });
        }

        function drawWeapon() {
            if (!gameState.player) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Get current weapon
            const weaponName = gameState.player.current_weapon || 'pistol';
            const weaponSprite = textures.sprites[weaponName];
            
            // Calculate weapon bob based on movement
            const bobAmount = Math.sin(Date.now() / 200) * 5;
            
            // Draw weapon sprite
            if (weaponSprite && weaponSprite.complete) {
                const weaponWidth = width / 2;
                const weaponHeight = weaponWidth * (weaponSprite.height / weaponSprite.width);
                
                // Draw weapon with bob effect
                ctx.drawImage(
                    weaponSprite,
                    width / 2 - weaponWidth / 2,
                    height - weaponHeight + bobAmount,
                    weaponWidth,
                    weaponHeight
                );
            } else {
                // Fallback if sprite isn't loaded
                ctx.fillStyle = '#555555';
                ctx.fillRect(width / 2 - 50, height - 100 + bobAmount, 100, 100);
            }
            
            // Draw weapon cooldown indicator
            if (gameState.player.weapon_cooldown > 0) {
                const cooldownWidth = 100;
                const cooldownHeight = 10;
                const cooldownX = width - cooldownWidth - 20;
                const cooldownY = height - 40;
                
                // Background
                ctx.fillStyle = '#333333';
                ctx.fillRect(cooldownX, cooldownY, cooldownWidth, cooldownHeight);
                
                // Get weapon cooldown from WEAPONS object
                const weaponCooldown = WEAPONS[weaponName] ? WEAPONS[weaponName].cooldown : 20;
                
                // Cooldown progress
                const cooldownPercent = gameState.player.weapon_cooldown / weaponCooldown;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(cooldownX, cooldownY, cooldownWidth * (1 - cooldownPercent), cooldownHeight);
            }
        }

        function drawBullets() {
            if (!gameState.player || !gameState.player.bullets) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.bullets.forEach(bullet => {
                // Calculate bullet position relative to player
                const dx = bullet.x - gameState.player.x;
                const dy = bullet.y - gameState.player.y;
                
                // Calculate angle to bullet
                let bulletAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (bulletAngle - gameState.player.angle > Math.PI) bulletAngle -= 2 * Math.PI;
                while (bulletAngle - gameState.player.angle < -Math.PI) bulletAngle += 2 * Math.PI;
                
                // Check if bullet is in field of view
                if (Math.abs(bulletAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate bullet distance
                    const bulletDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate bullet size based on distance
                    const bulletSize = Math.min(height / 30, 500 / bulletDist);
                    
                    // Calculate screen position
                    const angleToCenter = bulletAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw bullet with glow effect
                    ctx.save();
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bulletSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw bullet trail
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = bulletSize / 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(
                        screenX - Math.cos(bulletAngle - gameState.player.angle) * bulletSize * 4,
                        screenY - Math.sin(bulletAngle - gameState.player.angle) * bulletSize * 4
                    );
                    ctx.stroke();
                    
                    ctx.restore();
                }
            });
        }

        function drawExplosions() {
            if (!gameState.player || !gameState.player.explosions) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.explosions.forEach((explosion, index) => {
                // Play hit sound for new explosions
                if (explosion.time === 10 && index === 0) {
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.3;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Calculate explosion position relative to player
                const dx = explosion.x - gameState.player.x;
                const dy = explosion.y - gameState.player.y;
                
                // Calculate angle to explosion
                let explosionAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (explosionAngle - gameState.player.angle > Math.PI) explosionAngle -= 2 * Math.PI;
                while (explosionAngle - gameState.player.angle < -Math.PI) explosionAngle += 2 * Math.PI;
                
                // Check if explosion is in field of view
                if (Math.abs(explosionAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate explosion distance
                    const explosionDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate explosion size based on distance and time
                    const timeRatio = explosion.time / 10; // 10 is max time
                    const explosionSize = Math.min(50, 1000 / explosionDist) * (1 - timeRatio * 0.5);
                    
                    // Calculate screen position
                    const angleToCenter = explosionAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, explosionSize
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, explosionSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function drawPowerUps() {
            if (!gameState.power_ups || gameState.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.power_ups.forEach(powerUp => {
                // Calculate power-up position relative to player
                const dx = powerUp.x - gameState.player.x;
                const dy = powerUp.y - gameState.player.y;
                
                // Calculate angle to power-up
                let powerUpAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (powerUpAngle - gameState.player.angle > Math.PI) powerUpAngle -= 2 * Math.PI;
                while (powerUpAngle - gameState.player.angle < -Math.PI) powerUpAngle += 2 * Math.PI;
                
                // Calculate power-up distance
                const powerUpDist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if power-up is in field of view
                if (Math.abs(powerUpAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate power-up size based on distance
                    const powerUpSize = Math.min(height / 10, 2000 / powerUpDist);
                    
                    // Calculate screen position
                    const angleToCenter = powerUpAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Add bobbing motion
                    const bobAmount = Math.sin(Date.now() / 500 + powerUp.bob_offset) * 10;
                    const screenY = height / 2 + bobAmount;
                    
                    // Draw power-up with glow effect
                    ctx.save();
                    ctx.shadowColor = powerUp.color;
                    ctx.shadowBlur = 15;
                    
                    // Draw rotating cube or diamond shape
                    ctx.translate(screenX, screenY);
                    ctx.rotate(powerUp.rotation);
                    
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    if (powerUp.type === 'power') {
                        // Draw a star for power
                        const spikes = 5;
                        const outerRadius = powerUpSize;
                        const innerRadius = powerUpSize / 2;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                    } else if (powerUp.type === 'speed') {
                        // Draw a lightning bolt for speed
                        ctx.moveTo(-powerUpSize/2, -powerUpSize);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-powerUpSize/2, powerUpSize);
                        ctx.lineTo(powerUpSize/2, 0);
                        ctx.lineTo(0, -powerUpSize/2);
                        
                    } else if (powerUp.type === 'spread') {
                        // Draw a triple dot pattern for spread shot
                        ctx.arc(-powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(0, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
        }

        function drawPowerUpHUD() {
            if (!gameState.player.power_ups || gameState.player.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const iconSize = 30;
            const padding = 10;
            
            // Draw active power-ups in the corner
            gameState.player.power_ups.forEach((powerUp, index) => {
                const x = width - iconSize - padding;
                const y = padding + (iconSize + padding) * index;
                
                // Calculate remaining time
                const elapsed = Date.now() / 1000 - powerUp.start_time;
                const remaining = Math.max(0, powerUp.duration - elapsed);
                const timeRatio = remaining / powerUp.duration;
                
                // Draw power-up icon
                ctx.fillStyle = powerUp.type === 'power' ? '#ff0000' : 
                                powerUp.type === 'speed' ? '#00ff00' : '#0000ff';
                ctx.fillRect(x, y, iconSize, iconSize);
                
                // Draw timer bar
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y + iconSize + 2, iconSize * timeRatio, 3);
                
                // Draw icon symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.type === 'power' ? 'P' : 
                    powerUp.type === 'speed' ? 'S' : '3',
                    x + iconSize / 2, y + iconSize / 2
                );
            });
        }

        let use3DView = true;

        document.getElementById('toggleViewBtn').addEventListener('click', () => {
            use3DView = !use3DView;
            drawGame();
        });

        function drawGame() {
            try {
                console.log("Drawing game...");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (use3DView) {
                    try {
                        drawWalls();
                        
                        if (gameState.power_ups) {
                            drawPowerUps();
                        }
                        
                        if (gameState.player && gameState.player.bullets) {
                            drawBullets();
                        }
                        
                        if (gameState.fish) {
                            drawFish();
                        }
                        
                        if (gameState.player && gameState.player.explosions) {
                            drawExplosions();
                        }
                        
                        drawWeapon();
                        drawCrosshair();
                    } catch (error) {
                        console.error("Error in 3D view:", error);
                        drawFallbackView();
                        return;
                    }
                } else {
                    drawFallbackView();
                    return;
                }
                
                // Update UI
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                
                // Update health bar
                const healthPercent = gameState.player.health / 100;
                document.getElementById('healthFill').style.width = `${healthPercent * 100}%`;
                
                // Update ammo display
                if (gameState.player.ammo) {
                    document.getElementById('bulletAmmo').textContent = gameState.player.ammo.bullets || 0;
                    document.getElementById('shellAmmo').textContent = gameState.player.ammo.shells || 0;
                    document.getElementById('cellAmmo').textContent = gameState.player.ammo.cells || 0;
                }
                
                // Update weapon buttons
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    const weapon = btn.dataset.weapon;
                    
                    // Disable buttons for weapons the player doesn't have
                    if (gameState.player.weapons && !gameState.player.weapons.includes(weapon)) {
                        btn.disabled = true;
                        btn.style.opacity = 0.5;
                    } else {
                        btn.disabled = false;
                        btn.style.opacity = 1;
                    }
                    
                    // Highlight the current weapon
                    if (weapon === gameState.player.current_weapon) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                if (gameState.game_over) {
                    document.getElementById('gameOver').style.display = 'block';
                    clearInterval(gameInterval);
                }
                
                console.log("Game drawn successfully");
            } catch (error) {
                console.error("Error drawing game:", error);
                drawFallbackView();
            }
        }

        function showHitIndicator(x, y, damage) {
            // Create a floating damage indicator
            const indicator = document.createElement('div');
            indicator.textContent = `-${damage}`;
            indicator.style.position = 'absolute';
            indicator.style.color = '#ff0000';
            indicator.style.fontWeight = 'bold';
            indicator.style.fontSize = '24px';
            indicator.style.textShadow = '2px 2px 0 #000';
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            indicator.style.pointerEvents = 'none';
            indicator.style.zIndex = '1000';
            
            document.body.appendChild(indicator);
            
            // Animate the indicator
            let opacity = 1;
            let posY = y;
            
            const animate = () => {
                opacity -= 0.02;
                posY -= 1;
                
                indicator.style.opacity = opacity;
                indicator.style.top = `${posY}px`;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(indicator);
                }
            };
            
            animate();
        }

        // Update the updateGame function to check for fish health changes
        let previousFishHealth = {};

        function updateGame(newState) {
            console.log("Received game state:", newState);
            
            // Check for fish health changes
            if (newState.fish && gameState && gameState.fish) {
                newState.fish.forEach(fish => {
                    const fishId = `${fish.type}-${fish.x.toFixed(2)}-${fish.y.toFixed(2)}`;
                    
                    if (previousFishHealth[fishId] !== undefined && fish.health < previousFishHealth[fishId]) {
                        // Fish took damage
                        const damage = previousFishHealth[fishId] - fish.health;
                        
                        // Calculate screen position for the fish
                        const dx = fish.x - newState.player.x;
                        const dy = fish.y - newState.player.y;
                        const fishAngle = Math.atan2(dy, dx);
                        
                        if (Math.abs(fishAngle - newState.player.angle) < player.fov / 2) {
                            const width = canvas.width;
                            const height = canvas.height;
                            const angleToCenter = fishAngle - newState.player.angle;
                            const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                            const screenY = height / 2;
                            
                            // Show hit indicator
                            showHitIndicator(screenX, screenY, damage);
                            
                            // Play hit sound
                            const hitSound = document.getElementById('hitSound');
                            hitSound.volume = 0.3;
                            hitSound.currentTime = 0;
                            hitSound.play().catch(e => console.log("Audio play failed:", e));
                        }
                    }
                    
                    // Update previous health
                    previousFishHealth[fishId] = fish.health;
                });
            }
            
            gameState = newState;
            drawGame();
        }

        function setupControls() {
            // Touch controls
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('LEFT');
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('RIGHT');
            });
            document.getElementById('forwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('FORWARD');
            });
            document.getElementById('backwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('BACKWARD');
            });
            document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });
            
            // Mouse controls
            document.getElementById('leftBtn').addEventListener('mousedown', () => move('LEFT'));
            document.getElementById('rightBtn').addEventListener('mousedown', () => move('RIGHT'));
            document.getElementById('forwardBtn').addEventListener('mousedown', () => move('FORWARD'));
            document.getElementById('backwardBtn').addEventListener('mousedown', () => move('BACKWARD'));
            document.getElementById('shootBtn').addEventListener('click', shoot);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // Keyboard controls with continuous movement
            let keyState = {};
            
            document.addEventListener('keydown', (e) => {
                keyState[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
            });

            document.addEventListener('keyup', (e) => {
                keyState[e.key] = false;
            });

            // Continuous movement check
            setInterval(() => {
                if (keyState['ArrowLeft']) move('LEFT');
                if (keyState['ArrowRight']) move('RIGHT');
                if (keyState['ArrowUp']) move('FORWARD');
                if (keyState['ArrowDown']) move('BACKWARD');
            }, 50);
            
            // Mouse look
            canvas.addEventListener('mousemove', (e) => {
                if (e.buttons === 1) { // Left mouse button held down
                    const movementX = e.movementX || 0;
                    move('LOOK', movementX / 100);
                }
            });
        }

        function move(direction, amount = 1) {
            console.log(`Moving: ${direction}, amount: ${amount}`);
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ direction: direction, amount: amount })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Move response received");
                return response.json();
            })
            .then(data => {
                console.log("Move data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in move:', error);
                // Try to update the player position locally for better responsiveness
                if (gameState && gameState.player) {
                    const moveSpeed = 0.1;
                    const rotationSpeed = 0.05;
                    
                    if (direction === 'FORWARD') {
                        const newX = gameState.player.x + Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y + Math.sin(gameState.player.angle) * moveSpeed * amount;
                        // Check if new position is valid (not in a wall)
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'BACKWARD') {
                        const newX = gameState.player.x - Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y - Math.sin(gameState.player.angle) * moveSpeed * amount;
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'LEFT') {
                        gameState.player.angle -= rotationSpeed * amount;
                    } else if (direction === 'RIGHT') {
                        gameState.player.angle += rotationSpeed * amount;
                    } else if (direction === 'LOOK') {
                        gameState.player.angle += rotationSpeed * amount;
                    }
                    
                    drawGame();
                }
            });
        }

        function shoot() {
            console.log("Shooting!");
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shoot: true })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Shoot response received");
                return response.json();
            })
            .then(data => {
                console.log("Shoot data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in shoot:', error);
                
                // Create a local bullet if server request fails
                if (gameState && gameState.player) {
                    if (!gameState.player.bullets) {
                        gameState.player.bullets = [];
                    }
                    
                    // Add a new bullet
                    gameState.player.bullets.push({
                        x: gameState.player.x,
                        y: gameState.player.y,
                        angle: gameState.player.angle,
                        speed: 0.2 * (gameState.player.lure_speed || 1.0),
                        distance: 0,
                        max_distance: 10,
                        active: true
                    });
                    
                    // Play shoot sound
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.2;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                    
                    drawGame();
                }
            });
        }

        function resetGame() {
            console.log("Resetting game...");
            document.getElementById('gameOver').style.display = 'none';
            
            fetch('/reset', { method: 'POST' })
                .then(response => {
                    console.log("Reset response received");
                    return response.json();
                })
                .then(data => {
                    console.log("Reset data:", data);
                    updateGame(data);
                    
                    // Set up the game interval
                    console.log("Setting up game interval");
                    clearInterval(gameInterval);
                    gameInterval = setInterval(() => {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        })
                        .then(response => response.json())
                        .then(updateGame)
                        .catch(error => console.error('Error in game interval:', error));
                    }, 50);
                })
                .catch(error => console.error('Error resetting game:', error));
        }

        function drawFallbackView() {
            console.log("Drawing fallback view");
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw a simple background
            ctx.fillStyle = '#87CEEB';  // Sky blue
            ctx.fillRect(0, 0, width, height/2);
            
            ctx.fillStyle = '#0077be';  // Water blue
            ctx.fillRect(0, height/2, width, height/2);
            
            // Draw a simple grid to represent the map
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            
            const cellSize = 20;
            for (let y = 0; y < MAP.length; y++) {
                for (let x = 0; x < MAP[0].length; x++) {
                    const screenX = x * cellSize;
                    const screenY = y * cellSize;
                    
                    if (MAP[y][x] === 1) {
                        ctx.fillStyle = '#006400';  // Dark green for walls
                        ctx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                    
                    ctx.strokeRect(screenX, screenY, cellSize, cellSize);
                }
            }
            
            // Draw player position
            if (gameState && gameState.player) {
                const playerX = gameState.player.x * cellSize;
                const playerY = gameState.player.y * cellSize;
                
                ctx.fillStyle = '#ff0000';  // Red for player
                ctx.beginPath();
                ctx.arc(playerX, playerY, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw direction line
                const dirX = playerX + Math.cos(gameState.player.angle) * 10;
                const dirY = playerY + Math.sin(gameState.player.angle) * 10;
                
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(playerX, playerY);
                ctx.lineTo(dirX, dirY);
                ctx.stroke();
            }
            
            // Draw fish positions
            if (gameState && gameState.fish) {
                gameState.fish.forEach(fish => {
                    const fishX = fish.x * cellSize;
                    const fishY = fish.y * cellSize;
                    
                    ctx.fillStyle = FISH_TYPES[fish.type].color;
                    ctx.beginPath();
                    ctx.arc(fishX, fishY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            // Draw a message
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Fallback View - Check Console for Errors', width/2, 30);
        }

        document.getElementById('spawnFishBtn').addEventListener('click', spawnFish);

        function spawnFish() {
            console.log("Manually spawning fish");
            
            fetch('/spawn-fish', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ count: 1 })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Fish spawned:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error spawning fish:', error);
                
                // Create a local fish if server request fails
                if (gameState) {
                    if (!gameState.fish) {
                        gameState.fish = [];
                    }
                    
                    // Add a new fish at a random position
                    const fishTypes = Object.keys(FISH_TYPES);
                    const randomType = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                    
                    // Find a valid position (not in a wall and not too close to player)
                    let x, y, valid = false;
                    while (!valid) {
                        x = 1 + Math.random() * (MAP[0].length - 2);
                        y = 1 + Math.random() * (MAP.length - 2);
                        
                        // Check if position is in a wall
                        if (MAP[Math.floor(y)][Math.floor(x)] !== 0) {
                            continue;
                        }
                        
                        // Check if too close to player
                        const dist = Math.sqrt(
                            Math.pow(x - gameState.player.x, 2) + 
                            Math.pow(y - gameState.player.y, 2)
                        );
                        if (dist < 5) {
                            continue;
                        }
                        
                        valid = true;
                    }
                    
                    gameState.fish.push({
                        x: x,
                        y: y,
                        type: randomType,
                        health: FISH_TYPES[randomType].health,
                        direction: Math.random() * 2 * Math.PI,
                        speed: FISH_TYPES[randomType].speed,
                        state: 'patrol',
                        state_timer: 50 + Math.random() * 100
                    });
                    
                    console.log("Locally spawned fish:", gameState.fish[gameState.fish.length - 1]);
                    drawGame();
                }
            });
        }

        function drawCrosshair() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Check if any fish is in the crosshair
            let fishInCrosshair = false;
            
            if (gameState.fish) {
                gameState.fish.forEach(fish => {
                    // Calculate fish position relative to player
                    const dx = fish.x - gameState.player.x;
                    const dy = fish.y - gameState.player.y;
                    
                    // Calculate angle to fish
                    let fishAngle = Math.atan2(dy, dx);
                    
                    // Normalize angles
                    while (fishAngle - gameState.player.angle > Math.PI) fishAngle -= 2 * Math.PI;
                    while (fishAngle - gameState.player.angle < -Math.PI) fishAngle += 2 * Math.PI;
                    
                    // Calculate fish distance
                    const fishDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if fish is in center of view (crosshair)
                    if (Math.abs(fishAngle - gameState.player.angle) < 0.05 && fishDist < 10) {
                        fishInCrosshair = true;
                    }
                });
            }
            
            // Draw crosshair (red if fish in crosshair, white otherwise)
            ctx.strokeStyle = fishInCrosshair ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2);
            ctx.lineTo(width/2 + 10, height/2);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 10);
            ctx.lineTo(width/2, height/2 + 10);
            ctx.stroke();
            
            // Circle
            ctx.beginPath();
            ctx.arc(width/2, height/2, 5, 0, 2 * Math.PI);
            ctx.stroke();
            
            // If fish in crosshair, add a "target locked" indicator
            if (fishInCrosshair) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('TARGET LOCKED', width/2, height/2 + 30);
            }
        }

        document.getElementById('debugBtn').addEventListener('click', debugGame);

        function debugGame() {
            console.log("Debug info:");
            console.log("Player:", gameState.player);
            console.log("Fish:", gameState.fish);
            console.log("Bullets:", gameState.player.bullets);
            console.log("Power-ups:", gameState.power_ups);
            
            // Test shooting directly at a fish if any exist
            if (gameState.fish && gameState.fish.length > 0) {
                const fish = gameState.fish[0];
                const dx = fish.x - gameState.player.x;
                const dy = fish.y - gameState.player.y;
                
                // Calculate angle to fish
                const fishAngle = Math.atan2(dy, dx);
                
                // Update player angle to face fish
                gameState.player.angle = fishAngle;
                
                // Shoot at fish
                console.log("Aiming at fish:", fish);
                console.log("Angle to fish:", fishAngle);
                
                fetch('/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        direction: 'LOOK', 
                        amount: (fishAngle - gameState.player.angle) / 0.05,
                        shoot: true 
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Shot at fish, new state:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in debug shoot:', error));
            } else {
                console.log("No fish to target");
            }
        }

        document.getElementById('directHitBtn').addEventListener('click', directHit);

        function directHit() {
            console.log("Attempting direct hit on fish");
            
            if (gameState.fish && gameState.fish.length > 0) {
                fetch('/hit-fish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        index: 0,  // Hit the first fish
                        damage: 1  // Apply 1 damage
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Direct hit response:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in direct hit:', error));
            } else {
                console.log("No fish to hit");
            }
        }

        // Add weapon switching function
        function switchWeapon(weaponName) {
            if (!gameState.player.weapons.includes(weaponName)) {
                console.log(`Don't have weapon: ${weaponName}`);
                return;
            }
            
            console.log(`Switching to weapon: ${weaponName}`);
            
            fetch('/switch-weapon', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ weapon: weaponName })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Weapon switched:", data);
                updateGame(data);
                
                // Update weapon button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === weaponName) {
                        btn.classList.add('active');
                    }
                });
            })
            .catch(error => {
                console.error('Error switching weapon:', error);
                
                // Update locally if server request fails
                gameState.player.current_weapon = weaponName;
                drawGame();
                
                // Update weapon button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === weaponName) {
                        btn.classList.add('active');
                    }
                });
            });
        }

        // Add event listeners for weapon buttons
        document.querySelectorAll('.weapon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchWeapon(btn.dataset.weapon);
            });
        });

        // Add keyboard shortcuts for weapon switching
        document.addEventListener('keydown', function(event) {
            // Number keys 1-5 for weapon selection
            if (event.key >= '1' && event.key <= '5') {
                const weapons = ['pistol', 'shotgun', 'chaingun', 'plasma', 'bfg'];
                const weaponIndex = parseInt(event.key) - 1;
                if (weaponIndex < weapons.length) {
                    switchWeapon(weapons[weaponIndex]);
                }
            }
        });

        setupControls();
        resetGame();
    </script>
</body>
</html>