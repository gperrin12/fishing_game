<!DOCTYPE html>
<html>
<head>
    <title>Doom Fishing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: none;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 10px auto;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #555;
            background-color: #000;
            border-radius: 10px;
        }

        #score {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #ff0000;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #ammo {
            font-size: 1.2rem;
            margin: 5px 0;
            color: #ff9900;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #gameOver {
            display: none;
            color: #ff0000;
            font-size: 2rem;
            text-shadow: 3px 3px 0px #000;
            margin: 10px 0;
            text-align: center;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin: 20px auto;
        }

        .control-btn {
            padding: 15px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #8b0000;
            color: white;
            border: 2px solid #ff0000;
            border-radius: 10px;
            touch-action: manipulation;
        }

        #shootBtn {
            grid-column: 2;
            background-color: #ff0000;
        }

        #resetBtn {
            grid-column: 1 / span 3;
            background-color: #4CAF50;
        }

        #forwardBtn {
            grid-column: 2;
            grid-row: 1;
        }

        #backwardBtn {
            grid-column: 2;
            grid-row: 3;
        }

        #leftBtn {
            grid-column: 1;
            grid-row: 2;
        }

        #rightBtn {
            grid-column: 3;
            grid-row: 2;
        }

        #shootBtn {
            grid-column: 2;
            grid-row: 2;
        }

        @media (max-width: 600px) {
            .control-btn {
                padding: 12px;
                font-size: 1rem;
            }
        }

        /* Add weapon selection UI */
        #weaponSelector {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .weapon-btn {
            padding: 5px 10px;
            margin: 0 5px;
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
        }
        
        .weapon-btn.active {
            background-color: #ff0000;
            border-color: #ff6666;
        }
        
        /* Add health bar */
        #healthBar {
            width: 100%;
            max-width: 300px;
            height: 20px;
            background-color: #333;
            margin: 10px auto;
            border: 2px solid #666;
        }
        
        #healthFill {
            height: 100%;
            background-color: #ff0000;
            width: 100%;
        }
        
        /* Add ammo display */
        #ammoDisplay {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        .ammo-type {
            margin: 0 10px;
            color: #ff9900;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="ammo">Health: 100</div>
    <div id="gameOver">Game Over! The fish have taken over the lake!</div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="controls">
        <button class="control-btn" id="forwardBtn">‚Üë</button>
        <button class="control-btn" id="leftBtn">‚Üê</button>
        <button class="control-btn" id="shootBtn">üé£</button>
        <button class="control-btn" id="rightBtn">‚Üí</button>
        <button class="control-btn" id="backwardBtn">‚Üì</button>
        <button class="control-btn" id="resetBtn">New Game</button>
        <button class="control-btn" id="toggleViewBtn" style="background-color: #9c27b0;">Toggle View</button>
        <button class="control-btn" id="spawnFishBtn" style="background-color: #2196F3;">Spawn Fish</button>
        <button class="control-btn" id="debugBtn" style="background-color: #673AB7;">Debug</button>
        <button class="control-btn" id="directHitBtn" style="background-color: #E91E63;">Direct Hit</button>
    </div>

    <div id="healthBar"><div id="healthFill"></div></div>
    <div id="ammoDisplay">
        <div class="ammo-type">BULLETS: <span id="bulletAmmo">50</span></div>
        <div class="ammo-type">SHELLS: <span id="shellAmmo">0</span></div>
        <div class="ammo-type">CELLS: <span id="cellAmmo">0</span></div>
    </div>

    <div id="weaponSelector">
        <button class="weapon-btn active" data-weapon="pistol">PISTOL</button>
        <button class="weapon-btn" data-weapon="shotgun">SHOTGUN</button>
        <button class="weapon-btn" data-weapon="chaingun">CHAINGUN</button>
        <button class="weapon-btn" data-weapon="plasma">PLASMA</button>
        <button class="weapon-btn" data-weapon="bfg">BFG</button>
    </div>

    <audio id="splashSound" src="https://assets.mixkit.co/sfx/preview/mixkit-water-splash-1295.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>

    <script>
        // Debug mode
        const DEBUG = true;
        
        // Function to log debug messages
        function debug(message) {
            if (DEBUG) {
                console.log(`[DEBUG] ${message}`);
            }
        }
        
        // Verify canvas and context
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context!");
                return;
            }
            
            debug("Canvas and context initialized successfully");
        });

        console.log("Script starting...");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameInterval;
        
        // Game state
        let player = {
            x: 2,
            y: 2,
            angle: 0,
            fov: 60 * Math.PI / 180
        };
        
        // Fish types with properties
        const FISH_TYPES = {
            'bluegill': { color: '#4169E1', speed: 0.03, health: 1, damage: 1, points: 10 },
            'bass': { color: '#006400', speed: 0.02, health: 2, damage: 2, points: 20 },
            'pike': { color: '#8B4513', speed: 0.04, health: 1, damage: 3, points: 15 },
            'muskie': { color: '#DC143C', speed: 0.01, health: 4, damage: 5, points: 30 }
        };
        
        // Map definition (1 = wall, 0 = empty)
        const MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        
        // Game state
        let gameState = {
            player: {
                x: 2,
                y: 2,
                angle: 0,
                lures: 10,
                lure_power: 1.0,
                lure_speed: 1.0,
                power_ups: []
            },
            fish: [],
            score: 0,
            game_over: false,
            power_ups: []
        };

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = (containerWidth * 0.75) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function castRay(angle) {
            try {
                // Ray casting algorithm to find walls
                const rayDirX = Math.cos(angle);
                const rayDirY = Math.sin(angle);
                
                let mapX = Math.floor(gameState.player.x);
                let mapY = Math.floor(gameState.player.y);
                
                // Calculate distance to next x or y grid line
                let deltaDistX = Math.abs(1 / (rayDirX || 0.00001));
                let deltaDistY = Math.abs(1 / (rayDirY || 0.00001));
                
                let stepX, stepY;
                let sideDistX, sideDistY;
                
                // Calculate step and initial sideDist
                if (rayDirX < 0) {
                    stepX = -1;
                    sideDistX = (gameState.player.x - mapX) * deltaDistX;
                } else {
                    stepX = 1;
                    sideDistX = (mapX + 1.0 - gameState.player.x) * deltaDistX;
                }
                
                if (rayDirY < 0) {
                    stepY = -1;
                    sideDistY = (gameState.player.y - mapY) * deltaDistY;
                } else {
                    stepY = 1;
                    sideDistY = (mapY + 1.0 - gameState.player.y) * deltaDistY;
                }
                
                // Perform DDA
                let hit = 0;
                let side = 0;
                let maxDistance = 20; // Maximum ray distance
                let distance = 0;
                
                while (hit === 0 && distance < maxDistance) {
                    // Jump to next map square
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        side = 0;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        side = 1;
                    }
                    
                    distance += 1;
                    
                    // Check if ray has hit a wall
                    if (mapY < 0 || mapX < 0 || mapY >= MAP.length || mapX >= MAP[0].length) {
                        hit = 1; // Hit map boundary
                    } else if (MAP[mapY][mapX] > 0) {
                        hit = 1; // Hit wall
                    }
                }
                
                // Calculate distance projected on camera direction
                let perpWallDist;
                if (side === 0) {
                    perpWallDist = (mapX - gameState.player.x + (1 - stepX) / 2) / rayDirX;
                } else {
                    perpWallDist = (mapY - gameState.player.y + (1 - stepY) / 2) / rayDirY;
                }
                
                // Ensure we don't return infinity or NaN
                perpWallDist = Math.max(0.1, perpWallDist || 0.1);
                
                return {
                    distance: perpWallDist,
                    side: side,
                    mapX: mapX,
                    mapY: mapY,
                    stepX: stepX,
                    stepY: stepY
                };
            } catch (error) {
                console.error("Error in castRay:", error);
                // Return a default value to prevent crashes
                return {
                    distance: 5,
                    side: 0,
                    mapX: 0,
                    mapY: 0,
                    stepX: 1,
                    stepY: 1
                };
            }
        }

        function drawWalls() {
            try {
                debug("Drawing walls");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw sky (dark red for Doom's hellish sky)
                const skyGradient = ctx.createLinearGradient(0, 0, 0, height/2);
                skyGradient.addColorStop(0, "#350000");
                skyGradient.addColorStop(1, "#5a0000");
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, width, height/2);
                
                // Draw floor (dark brown)
                const floorGradient = ctx.createLinearGradient(0, height/2, 0, height);
                floorGradient.addColorStop(0, "#301810");
                floorGradient.addColorStop(1, "#181010");
                ctx.fillStyle = floorGradient;
                ctx.fillRect(0, height/2, width, height/2);
                
                // Only proceed with raycasting if textures are loaded
                if (!texturesLoaded) {
                    debug("Textures not loaded yet, drawing placeholder walls");
                    return true;
                }
                
                // Get player position and angle
                const playerX = gameState.player.x;
                const playerY = gameState.player.y;
                const playerAngle = gameState.player.angle;
                
                // Ray casting loop
                for (let x = 0; x < width; x++) {
                    // Calculate ray position and direction
                    const cameraX = 2 * x / width - 1; // x-coordinate in camera space
                    const rayDirX = Math.cos(playerAngle) + Math.sin(playerAngle) * cameraX;
                    const rayDirY = Math.sin(playerAngle) - Math.cos(playerAngle) * cameraX;
                    
                    // Which box of the map we're in
                    let mapX = Math.floor(playerX);
                    let mapY = Math.floor(playerY);
                    
                    // Length of ray from current position to next x or y-side
                    let sideDistX, sideDistY;
                    
                    // Length of ray from one x or y-side to next x or y-side
                    const deltaDistX = Math.abs(1 / rayDirX);
                    const deltaDistY = Math.abs(1 / rayDirY);
                    
                    // Direction to step in x or y direction (either +1 or -1)
                    let stepX, stepY;
                    
                    // Calculate step and initial sideDist
                    if (rayDirX < 0) {
                        stepX = -1;
                        sideDistX = (playerX - mapX) * deltaDistX;
                    } else {
                        stepX = 1;
                        sideDistX = (mapX + 1.0 - playerX) * deltaDistX;
                    }
                    
                    if (rayDirY < 0) {
                        stepY = -1;
                        sideDistY = (playerY - mapY) * deltaDistY;
                    } else {
                        stepY = 1;
                        sideDistY = (mapY + 1.0 - playerY) * deltaDistY;
                    }
                    
                    // Perform DDA (Digital Differential Analysis)
                    let hit = 0; // Was there a wall hit?
                    let side = 0; // Was a NS or a EW wall hit?
                    
                    while (hit === 0) {
                        // Jump to next map square, either in x-direction, or in y-direction
                        if (sideDistX < sideDistY) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                            side = 0;
                        } else {
                            sideDistY += deltaDistY;
                            mapY += stepY;
                            side = 1;
                        }
                        
                        // Check if ray has hit a wall
                        if (mapX < 0 || mapY < 0 || mapX >= MAP[0].length || mapY >= MAP.length) {
                            hit = 1; // Out of bounds
                        } else if (MAP[mapY][mapX] > 0) {
                            hit = MAP[mapY][mapX]; // Wall type
                        }
                    }
                    
                    // Calculate distance projected on camera direction
                    let perpWallDist;
                    if (side === 0) {
                        perpWallDist = (mapX - playerX + (1 - stepX) / 2) / rayDirX;
                    } else {
                        perpWallDist = (mapY - playerY + (1 - stepY) / 2) / rayDirY;
                    }
                    
                    // Calculate height of line to draw on screen
                    const lineHeight = Math.floor(height / perpWallDist);
                    
                    // Calculate lowest and highest pixel to fill in current stripe
                    let drawStart = Math.max(0, Math.floor(-lineHeight / 2 + height / 2));
                    let drawEnd = Math.min(height - 1, Math.floor(lineHeight / 2 + height / 2));
                    
                    // Select texture based on wall type
                    const wallType = hit;
                    let wallTexture;
                    
                    switch (wallType) {
                        case 2: // Tech wall
                            wallTexture = textures.walls.tech;
                            break;
                        case 3: // Slime wall
                            wallTexture = textures.walls.slime;
                            break;
                        case 4: // Blood wall
                            wallTexture = textures.walls.blood;
                            break;
                        case 5: // Metal wall
                            wallTexture = textures.walls.metal;
                            break;
                        default: // Default red brick
                            wallTexture = textures.walls.default;
                    }
                    
                    // Calculate where exactly the wall was hit
                    let wallX;
                    if (side === 0) {
                        wallX = playerY + perpWallDist * rayDirY;
                    } else {
                        wallX = playerX + perpWallDist * rayDirX;
                    }
                    wallX -= Math.floor(wallX);
                    
                    // X coordinate on the texture
                    let texX = Math.floor(wallX * wallTexture.width);
                    if (side === 0 && rayDirX > 0) texX = wallTexture.width - texX - 1;
                    if (side === 1 && rayDirY < 0) texX = wallTexture.width - texX - 1;
                    
                    // How much to increase the texture coordinate per screen pixel
                    const step = wallTexture.height / lineHeight;
                    // Starting texture coordinate
                    let texPos = (drawStart - height / 2 + lineHeight / 2) * step;
                    
                    // Draw the textured wall slice
                    for (let y = drawStart; y < drawEnd; y++) {
                        // Cast the texture coordinate to integer, and mask with (texHeight - 1)
                        const texY = Math.floor(texPos) & (wallTexture.height - 1);
                        texPos += step;
                        
                        // Draw pixel from texture
                        try {
                            // Apply shading based on distance and side
                            let shade = 1.0;
                            if (side === 1) shade = 0.7; // Darker for y-side walls
                            
                            // Apply distance shading (fog effect)
                            shade *= Math.min(1.0, 5.0 / perpWallDist);
                            
                            // Draw a single pixel
                            ctx.fillStyle = `rgba(${shade * 255}, ${shade * 255}, ${shade * 255}, 1.0)`;
                            ctx.fillRect(x, y, 1, 1);
                        } catch (e) {
                            console.error("Error drawing textured wall:", e);
                        }
                    }
                }
                
                debug("Walls drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawWalls:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawFish() {
            try {
                debug("Drawing fish as Doom monsters");
                if (!gameState.fish || gameState.fish.length === 0) return true;
                
                const width = canvas.width;
                const height = canvas.height;
                
                // Sort sprites by distance (furthest first for proper rendering)
                const sprites = gameState.fish.slice().sort((a, b) => {
                    const distA = Math.pow(a.x - gameState.player.x, 2) + Math.pow(a.y - gameState.player.y, 2);
                    const distB = Math.pow(b.x - gameState.player.x, 2) + Math.pow(b.y - gameState.player.y, 2);
                    return distB - distA;
                });
                
                sprites.forEach(fish => {
                    // Calculate sprite position relative to player
                    const spriteX = fish.x - gameState.player.x;
                    const spriteY = fish.y - gameState.player.y;
                    
                    // Transform sprite with the inverse camera matrix
                    const invDet = 1.0 / (Math.cos(gameState.player.angle) * Math.sin(gameState.player.angle + Math.PI/2) - 
                                          Math.sin(gameState.player.angle) * Math.cos(gameState.player.angle + Math.PI/2));
                    
                    const transformX = invDet * (Math.sin(gameState.player.angle + Math.PI/2) * spriteX - 
                                                 Math.cos(gameState.player.angle + Math.PI/2) * spriteY);
                    
                    const transformY = invDet * (-Math.sin(gameState.player.angle) * spriteX + 
                                                 Math.cos(gameState.player.angle) * spriteY);
                    
                    // Skip if behind player
                    if (transformY <= 0) return;
                    
                    // Calculate sprite screen position
                    const spriteScreenX = Math.floor((width / 2) * (1 + transformX / transformY));
                    
                    // Calculate sprite size
                    const spriteSize = Math.min(height, Math.floor(height / transformY * 0.75));
                    
                    // Draw the sprite
                    const halfSize = spriteSize / 2;
                    const drawStartX = Math.max(0, spriteScreenX - halfSize);
                    const drawEndX = Math.min(width - 1, spriteScreenX + halfSize);
                    const drawStartY = Math.max(0, height / 2 - halfSize);
                    const drawEndY = Math.min(height - 1, height / 2 + halfSize);
                    
                    // Select sprite texture based on fish type
                    let spriteTexture;
                    switch (fish.type) {
                        case 'imp':
                            spriteTexture = textures.sprites.imp;
                            break;
                        case 'demon':
                            spriteTexture = textures.sprites.demon;
                            break;
                        case 'cacodemon':
                            spriteTexture = textures.sprites.cacodemon;
                            break;
                        case 'baron':
                            spriteTexture = textures.sprites.baron;
                            break;
                        default:
                            spriteTexture = textures.sprites.imp; // Default to imp
                    }
                    
                    // Calculate scaling factors
                    const heightScale = spriteSize / spriteTexture.height;
                    const widthScale = spriteSize / spriteTexture.width;
                    
                    // Draw the sprite
                    ctx.save();
                    ctx.translate(spriteScreenX, height / 2);
                    ctx.scale(widthScale, heightScale);
                    ctx.drawImage(spriteTexture, -spriteTexture.width/2, -spriteTexture.height/2);
                    
                    // Add health bar above enemy
                    const healthPercent = fish.health / FISH_TYPES[fish.type].health;
                    const barWidth = spriteTexture.width * 0.8;
                    const barHeight = 5;
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(-barWidth/2, -spriteTexture.height/2 - 10, barWidth, barHeight);
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(-barWidth/2, -spriteTexture.height/2 - 10, barWidth * healthPercent, barHeight);
                    
                    ctx.restore();
                });
                
                debug("Fish drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawFish:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawWeapon() {
            try {
                debug("Drawing weapon");
                if (!gameState.player || !gameState.player.current_weapon) return true;
                
                const width = canvas.width;
                const height = canvas.height;
                
                // Select weapon sprite based on current weapon
                let weaponSprite;
                switch (gameState.player.current_weapon) {
                    case 'pistol':
                        weaponSprite = textures.sprites.pistol;
                        break;
                    case 'shotgun':
                        weaponSprite = textures.sprites.shotgun;
                        break;
                    case 'chaingun':
                        weaponSprite = textures.sprites.chaingun;
                        break;
                    case 'plasma':
                        weaponSprite = textures.sprites.plasma;
                        break;
                    case 'bfg':
                        weaponSprite = textures.sprites.bfg;
                        break;
                    default:
                        weaponSprite = textures.sprites.pistol; // Default to pistol
                }
                
                // Calculate weapon position (bouncing effect while moving)
                const bounceY = Math.sin(Date.now() / 150) * 10 * (isMoving ? 1 : 0.2);
                const weaponX = width / 2;
                const weaponY = height - weaponSprite.height / 3 + bounceY;
                
                // Draw weapon
                const scale = 0.8; // Scale the weapon sprite
                ctx.save();
                ctx.translate(weaponX, weaponY);
                ctx.scale(scale, scale);
                ctx.drawImage(weaponSprite, -weaponSprite.width/2, -weaponSprite.height/2);
                ctx.restore();
                
                debug("Weapon drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawWeapon:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawBullets() {
            if (!gameState.player || !gameState.player.bullets) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.bullets.forEach(bullet => {
                // Calculate bullet position relative to player
                const dx = bullet.x - gameState.player.x;
                const dy = bullet.y - gameState.player.y;
                
                // Calculate angle to bullet
                let bulletAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (bulletAngle - gameState.player.angle > Math.PI) bulletAngle -= 2 * Math.PI;
                while (bulletAngle - gameState.player.angle < -Math.PI) bulletAngle += 2 * Math.PI;
                
                // Check if bullet is in field of view
                if (Math.abs(bulletAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate bullet distance
                    const bulletDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate bullet size based on distance
                    const bulletSize = Math.min(height / 30, 500 / bulletDist);
                    
                    // Calculate screen position
                    const angleToCenter = bulletAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw bullet with glow effect
                    ctx.save();
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bulletSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw bullet trail
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = bulletSize / 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(
                        screenX - Math.cos(bulletAngle - gameState.player.angle) * bulletSize * 4,
                        screenY - Math.sin(bulletAngle - gameState.player.angle) * bulletSize * 4
                    );
                    ctx.stroke();
                    
                    ctx.restore();
                }
            });
        }

        function drawExplosions() {
            if (!gameState.player || !gameState.player.explosions) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.explosions.forEach((explosion, index) => {
                // Play hit sound for new explosions
                if (explosion.time === 10 && index === 0) {
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.3;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Calculate explosion position relative to player
                const dx = explosion.x - gameState.player.x;
                const dy = explosion.y - gameState.player.y;
                
                // Calculate angle to explosion
                let explosionAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (explosionAngle - gameState.player.angle > Math.PI) explosionAngle -= 2 * Math.PI;
                while (explosionAngle - gameState.player.angle < -Math.PI) explosionAngle += 2 * Math.PI;
                
                // Check if explosion is in field of view
                if (Math.abs(explosionAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate explosion distance
                    const explosionDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate explosion size based on distance and time
                    const timeRatio = explosion.time / 10; // 10 is max time
                    const explosionSize = Math.min(50, 1000 / explosionDist) * (1 - timeRatio * 0.5);
                    
                    // Calculate screen position
                    const angleToCenter = explosionAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, explosionSize
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, explosionSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function drawPowerUps() {
            if (!gameState.power_ups || gameState.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.power_ups.forEach(powerUp => {
                // Calculate power-up position relative to player
                const dx = powerUp.x - gameState.player.x;
                const dy = powerUp.y - gameState.player.y;
                
                // Calculate angle to power-up
                let powerUpAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (powerUpAngle - gameState.player.angle > Math.PI) powerUpAngle -= 2 * Math.PI;
                while (powerUpAngle - gameState.player.angle < -Math.PI) powerUpAngle += 2 * Math.PI;
                
                // Calculate power-up distance
                const powerUpDist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if power-up is in field of view
                if (Math.abs(powerUpAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate power-up size based on distance
                    const powerUpSize = Math.min(height / 10, 2000 / powerUpDist);
                    
                    // Calculate screen position
                    const angleToCenter = powerUpAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Add bobbing motion
                    const bobAmount = Math.sin(Date.now() / 500 + powerUp.bob_offset) * 10;
                    const screenY = height / 2 + bobAmount;
                    
                    // Draw power-up with glow effect
                    ctx.save();
                    ctx.shadowColor = powerUp.color;
                    ctx.shadowBlur = 15;
                    
                    // Draw rotating cube or diamond shape
                    ctx.translate(screenX, screenY);
                    ctx.rotate(powerUp.rotation);
                    
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    if (powerUp.type === 'power') {
                        // Draw a star for power
                        const spikes = 5;
                        const outerRadius = powerUpSize;
                        const innerRadius = powerUpSize / 2;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                    } else if (powerUp.type === 'speed') {
                        // Draw a lightning bolt for speed
                        ctx.moveTo(-powerUpSize/2, -powerUpSize);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-powerUpSize/2, powerUpSize);
                        ctx.lineTo(powerUpSize/2, 0);
                        ctx.lineTo(0, -powerUpSize/2);
                        
                    } else if (powerUp.type === 'spread') {
                        // Draw a triple dot pattern for spread shot
                        ctx.arc(-powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(0, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
        }

        function drawPowerUpHUD() {
            if (!gameState.player.power_ups || gameState.player.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const iconSize = 30;
            const padding = 10;
            
            // Draw active power-ups in the corner
            gameState.player.power_ups.forEach((powerUp, index) => {
                const x = width - iconSize - padding;
                const y = padding + (iconSize + padding) * index;
                
                // Calculate remaining time
                const elapsed = Date.now() / 1000 - powerUp.start_time;
                const remaining = Math.max(0, powerUp.duration - elapsed);
                const timeRatio = remaining / powerUp.duration;
                
                // Draw power-up icon
                ctx.fillStyle = powerUp.type === 'power' ? '#ff0000' : 
                                powerUp.type === 'speed' ? '#00ff00' : '#0000ff';
                ctx.fillRect(x, y, iconSize, iconSize);
                
                // Draw timer bar
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y + iconSize + 2, iconSize * timeRatio, 3);
                
                // Draw icon symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.type === 'power' ? 'P' : 
                    powerUp.type === 'speed' ? 'S' : '3',
                    x + iconSize / 2, y + iconSize / 2
                );
            });
        }

        // Global variable to track view mode
        let use3DView = true;

        // Function to toggle between 3D and 2D views
        function toggleViewSimple() {
            debug("Toggle view button clicked");
            use3DView = !use3DView;
            
            const toggleBtn = document.getElementById('toggleViewBtn');
            if (toggleBtn) {
                toggleBtn.textContent = use3DView ? 'Switch to 2D' : 'Switch to 3D';
            }
            
            debug(`View set to ${use3DView ? '3D' : '2D'}`);
            drawGame();
        }
        
        // Setup the toggle view button with a simple approach
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('toggleViewBtn');
            if (toggleBtn) {
                debug("Setting up toggle view button");
                toggleBtn.addEventListener('click', toggleViewSimple);
            }
        });

        // Update the drawGame function to properly handle the view mode
        function drawGame() {
            try {
                debug(`Drawing game in ${use3DView ? '3D' : '2D'} mode...`);
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (use3DView) {
                    debug("Drawing 3D view");
                    
                    // Draw basic elements
                    if (!drawWalls()) {
                        throw new Error("Failed to draw walls");
                    }
                    
                    // Draw fish (enemies)
                    if (gameState.fish && gameState.fish.length > 0) {
                        if (!drawFish()) {
                            throw new Error("Failed to draw fish");
                        }
                    }
                    
                    // Draw bullets
                    if (gameState.player && gameState.player.bullets && gameState.player.bullets.length > 0) {
                        if (!drawBullets()) {
                            throw new Error("Failed to draw bullets");
                        }
                    }
                    
                    // Draw pickups
                    if (gameState.pickups && gameState.pickups.length > 0) {
                        if (!drawPickups()) {
                            throw new Error("Failed to draw pickups");
                        }
                    }
                    
                    // Draw weapon
                    if (!drawWeapon()) {
                        throw new Error("Failed to draw weapon");
                    }
                    
                    // Draw Doom-style HUD
                    if (!drawDoomHUD()) {
                        throw new Error("Failed to draw HUD");
                    }
                    
                    // Draw crosshair
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, centerY);
                    ctx.lineTo(centerX + 10, centerY);
                    ctx.moveTo(centerX, centerY - 10);
                    ctx.lineTo(centerX, centerY + 10);
                    ctx.stroke();
                } else {
                    debug("Drawing 2D view");
                    draw2DView();
                }
                
                // Update UI elements
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                
                if (gameState.player && gameState.player.health !== undefined) {
                    document.getElementById('ammo').textContent = `Health: ${gameState.player.health}`;
                }
                
                if (gameState.game_over) {
                    document.getElementById('gameOver').style.display = 'block';
                }
                
                debug("Drawing game completed successfully");
            } catch (error) {
                console.error("Error drawing game:", error);
                console.error(error.stack);
                
                // Draw a simple error message
                ctx.fillStyle = '#ff0000';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Error drawing game', canvas.width / 2, canvas.height / 2);
                ctx.fillText('Check console for details', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        // Add a 2D top-down view function
        function draw2DView() {
            try {
                debug("Drawing 2D view");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw background
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, width, height);
                
                // Draw a simple grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                const gridSize = 20;
                const cellSize = Math.min(width, height) / gridSize;
                
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
                
                // Draw player as a yellow circle with direction
                if (gameState.player) {
                    const playerX = gameState.player.x * cellSize;
                    const playerY = gameState.player.y * cellSize;
                    
                    // Draw player circle
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(playerX, playerY, cellSize/2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw direction line
                    const dirX = Math.cos(gameState.player.angle) * cellSize;
                    const dirY = Math.sin(gameState.player.angle) * cellSize;
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playerX, playerY);
                    ctx.lineTo(playerX + dirX, playerY + dirY);
                    ctx.stroke();
                }
                
                debug("2D view drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in draw2DView:", error);
                console.error(error.stack);
                return false;
            }
        }

        // Helper function to get wall color based on wall type
        function getWallColor(wallType) {
            switch(wallType) {
                case 1: return '#8b0000';  // Dark red for stone walls
                case 2: return '#4682b4';  // Steel blue for tech walls
                case 3: return '#006400';  // Dark green for slime walls
                case 4: return '#8b0000';  // Dark red for blood walls
                case 5: return '#708090';  // Slate gray for metal walls
                default: return '#8b0000';  // Default to dark red
            }
        }

        // Update UI elements
        function updateUI() {
            // Update score
            document.getElementById('score').textContent = `Score: ${gameState.score}`;
            
            // Update health
            if (gameState.player && gameState.player.health !== undefined) {
                document.getElementById('ammo').textContent = `Health: ${gameState.player.health}`;
                
                // Update health bar
                const healthPercent = gameState.player.health / 100;
                document.getElementById('healthFill').style.width = `${healthPercent * 100}%`;
            }
            
            // Update ammo display
            if (gameState.player && gameState.player.ammo) {
                document.getElementById('bulletAmmo').textContent = gameState.player.ammo.bullets || 0;
                document.getElementById('shellAmmo').textContent = gameState.player.ammo.shells || 0;
                document.getElementById('cellAmmo').textContent = gameState.player.ammo.cells || 0;
            }
            
            // Check for game over
            if (gameState.game_over) {
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function showHitIndicator(x, y, damage) {
            // Create a floating damage indicator
            const indicator = document.createElement('div');
            indicator.textContent = `-${damage}`;
            indicator.style.position = 'absolute';
            indicator.style.color = '#ff0000';
            indicator.style.fontWeight = 'bold';
            indicator.style.fontSize = '24px';
            indicator.style.textShadow = '2px 2px 0 #000';
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            indicator.style.pointerEvents = 'none';
            indicator.style.zIndex = '1000';
            
            document.body.appendChild(indicator);
            
            // Animate the indicator
            let opacity = 1;
            let posY = y;
            
            const animate = () => {
                opacity -= 0.02;
                posY -= 1;
                
                indicator.style.opacity = opacity;
                indicator.style.top = `${posY}px`;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(indicator);
                }
            };
            
            animate();
        }

        // Update the updateGame function to check for fish health changes
        let previousFishHealth = {};

        function updateGame(newState) {
            console.log("Received game state:", newState);
            
            // Check for fish health changes
            if (newState.fish && gameState && gameState.fish) {
                newState.fish.forEach(fish => {
                    const fishId = `${fish.type}-${fish.x.toFixed(2)}-${fish.y.toFixed(2)}`;
                    
                    if (previousFishHealth[fishId] !== undefined && fish.health < previousFishHealth[fishId]) {
                        // Fish took damage
                        const damage = previousFishHealth[fishId] - fish.health;
                        
                        // Calculate screen position for the fish
                        const dx = fish.x - newState.player.x;
                        const dy = fish.y - newState.player.y;
                        const fishAngle = Math.atan2(dy, dx);
                        
                        if (Math.abs(fishAngle - newState.player.angle) < player.fov / 2) {
                            const width = canvas.width;
                            const height = canvas.height;
                            const angleToCenter = fishAngle - newState.player.angle;
                            const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                            const screenY = height / 2;
                            
                            // Show hit indicator
                            showHitIndicator(screenX, screenY, damage);
                            
                            // Play hit sound
                            const hitSound = document.getElementById('hitSound');
                            hitSound.volume = 0.3;
                            hitSound.currentTime = 0;
                            hitSound.play().catch(e => console.log("Audio play failed:", e));
                        }
                    }
                    
                    // Update previous health
                    previousFishHealth[fishId] = fish.health;
                });
            }
            
            gameState = newState;
            drawGame();
        }

        // Track player movement for weapon bounce
        let isMoving = false;
        
        // Update the setupControls function to track movement
        function setupControls() {
            // Touch controls
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('LEFT');
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('RIGHT');
            });
            document.getElementById('forwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('FORWARD');
            });
            document.getElementById('backwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('BACKWARD');
            });
            document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });
            
            // Mouse controls
            document.getElementById('leftBtn').addEventListener('mousedown', () => move('LEFT'));
            document.getElementById('rightBtn').addEventListener('mousedown', () => move('RIGHT'));
            document.getElementById('forwardBtn').addEventListener('mousedown', () => move('FORWARD'));
            document.getElementById('backwardBtn').addEventListener('mousedown', () => move('BACKWARD'));
            document.getElementById('shootBtn').addEventListener('click', shoot);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // Keyboard controls with continuous movement
            let keyState = {};
            
            document.addEventListener('keydown', (e) => {
                keyState[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
            });

            document.addEventListener('keyup', (e) => {
                keyState[e.key] = false;
            });

            // Continuous movement check
            setInterval(() => {
                if (keyState['ArrowLeft']) move('LEFT');
                if (keyState['ArrowRight']) move('RIGHT');
                if (keyState['ArrowUp']) move('FORWARD');
                if (keyState['ArrowDown']) move('BACKWARD');
            }, 50);
            
            // Mouse look
            canvas.addEventListener('mousemove', (e) => {
                if (e.buttons === 1) { // Left mouse button held down
                    const movementX = e.movementX || 0;
                    move('LOOK', movementX / 100);
                }
            });
            
            // Track movement for weapon bounce
            document.getElementById('forwardBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('backwardBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('leftBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('rightBtn').addEventListener('mousedown', () => isMoving = true);
            
            document.getElementById('forwardBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('backwardBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('leftBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('rightBtn').addEventListener('mouseup', () => isMoving = false);
            
            // Track keyboard movement
            document.addEventListener('keydown', function(event) {
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    isMoving = true;
                }
            });
            
            document.addEventListener('keyup', function(event) {
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    isMoving = false;
                }
            });
        }

        function move(direction, amount = 1) {
            console.log(`Moving: ${direction}, amount: ${amount}`);
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ direction: direction, amount: amount })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Move response received");
                return response.json();
            })
            .then(data => {
                console.log("Move data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in move:', error);
                // Try to update the player position locally for better responsiveness
                if (gameState && gameState.player) {
                    const moveSpeed = 0.1;
                    const rotationSpeed = 0.05;
                    
                    if (direction === 'FORWARD') {
                        const newX = gameState.player.x + Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y + Math.sin(gameState.player.angle) * moveSpeed * amount;
                        // Check if new position is valid (not in a wall)
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'BACKWARD') {
                        const newX = gameState.player.x - Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y - Math.sin(gameState.player.angle) * moveSpeed * amount;
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'LEFT') {
                        gameState.player.angle -= rotationSpeed * amount;
                    } else if (direction === 'RIGHT') {
                        gameState.player.angle += rotationSpeed * amount;
                    } else if (direction === 'LOOK') {
                        gameState.player.angle += rotationSpeed * amount;
                    }
                    
                    drawGame();
                }
            });
        }

        function shoot() {
            console.log("Shooting!");
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shoot: true })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Shoot response received");
                return response.json();
            })
            .then(data => {
                console.log("Shoot data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in shoot:', error);
                
                // Create a local bullet if server request fails
                if (gameState && gameState.player) {
                    if (!gameState.player.bullets) {
                        gameState.player.bullets = [];
                    }
                    
                    // Add a new bullet
                    gameState.player.bullets.push({
                        x: gameState.player.x,
                        y: gameState.player.y,
                        angle: gameState.player.angle,
                        speed: 0.2 * (gameState.player.lure_speed || 1.0),
                        distance: 0,
                        max_distance: 10,
                        active: true
                    });
                    
                    // Play shoot sound
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.2;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                    
                    drawGame();
                }
            });
        }

        function resetGame() {
            console.log("Resetting game...");
            document.getElementById('gameOver').style.display = 'none';
            
            fetch('/reset', { method: 'POST' })
                .then(response => {
                    console.log("Reset response received");
                    return response.json();
                })
                .then(data => {
                    console.log("Reset data:", data);
                    updateGame(data);
                    
                    // Set up the game interval
                    console.log("Setting up game interval");
                    clearInterval(gameInterval);
                    gameInterval = setInterval(() => {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        })
                        .then(response => response.json())
                        .then(updateGame)
                        .catch(error => console.error('Error in game interval:', error));
                    }, 50);
                })
                .catch(error => console.error('Error resetting game:', error));
        }

        function drawCrosshair() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Check if any fish is in the crosshair
            let fishInCrosshair = false;
            
            if (gameState.fish) {
                gameState.fish.forEach(fish => {
                    // Calculate fish position relative to player
                    const dx = fish.x - gameState.player.x;
                    const dy = fish.y - gameState.player.y;
                    
                    // Calculate angle to fish
                    let fishAngle = Math.atan2(dy, dx);
                    
                    // Normalize angles
                    while (fishAngle - gameState.player.angle > Math.PI) fishAngle -= 2 * Math.PI;
                    while (fishAngle - gameState.player.angle < -Math.PI) fishAngle += 2 * Math.PI;
                    
                    // Calculate fish distance
                    const fishDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if fish is in center of view (crosshair)
                    if (Math.abs(fishAngle - gameState.player.angle) < 0.05 && fishDist < 10) {
                        fishInCrosshair = true;
                    }
                });
            }
            
            // Draw crosshair (red if fish in crosshair, white otherwise)
            ctx.strokeStyle = fishInCrosshair ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2);
            ctx.lineTo(width/2 + 10, height/2);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 10);
            ctx.lineTo(width/2, height/2 + 10);
            ctx.stroke();
            
            // Circle
            ctx.beginPath();
            ctx.arc(width/2, height/2, 5, 0, 2 * Math.PI);
            ctx.stroke();
            
            // If fish in crosshair, add a "target locked" indicator
            if (fishInCrosshair) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('TARGET LOCKED', width/2, height/2 + 30);
            }
        }

        document.getElementById('debugBtn').addEventListener('click', debugGame);

        function debugGame() {
            console.log("Debug info:");
            console.log("Player:", gameState.player);
            console.log("Fish:", gameState.fish);
            console.log("Bullets:", gameState.player.bullets);
            console.log("Power-ups:", gameState.power_ups);
            
            // Test shooting directly at a fish if any exist
            if (gameState.fish && gameState.fish.length > 0) {
                const fish = gameState.fish[0];
                const dx = fish.x - gameState.player.x;
                const dy = fish.y - gameState.player.y;
                
                // Calculate angle to fish
                const fishAngle = Math.atan2(dy, dx);
                
                // Update player angle to face fish
                gameState.player.angle = fishAngle;
                
                // Shoot at fish
                console.log("Aiming at fish:", fish);
                console.log("Angle to fish:", fishAngle);
                
                fetch('/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        direction: 'LOOK', 
                        amount: (fishAngle - gameState.player.angle) / 0.05,
                        shoot: true 
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Shot at fish, new state:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in debug shoot:', error));
            } else {
                console.log("No fish to target");
            }
        }

        document.getElementById('directHitBtn').addEventListener('click', directHit);

        function directHit() {
            console.log("Attempting direct hit on fish");
            
            if (gameState.fish && gameState.fish.length > 0) {
                fetch('/hit-fish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        index: 0,  // Hit the first fish
                        damage: 1  // Apply 1 damage
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Direct hit response:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in direct hit:', error));
            } else {
                console.log("No fish to hit");
            }
        }

        // Add weapon switching function
        function switchWeapon(weaponName) {
            if (!gameState.player.weapons.includes(weaponName)) {
                console.log(`Don't have weapon: ${weaponName}`);
                return;
            }
            
            console.log(`Switching to weapon: ${weaponName}`);
            
            fetch('/switch-weapon', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ weapon: weaponName })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Weapon switched:", data);
                updateGame(data);
                
                // Update weapon button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === weaponName) {
                        btn.classList.add('active');
                    }
                });
            })
            .catch(error => {
                console.error('Error switching weapon:', error);
                
                // Update locally if server request fails
                gameState.player.current_weapon = weaponName;
                drawGame();
                
                // Update weapon button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === weaponName) {
                        btn.classList.add('active');
                    }
                });
            });
        }

        // Add event listeners for weapon buttons
        document.querySelectorAll('.weapon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchWeapon(btn.dataset.weapon);
            });
        });

        // Add keyboard shortcuts for weapon switching
        document.addEventListener('keydown', function(event) {
            // Number keys 1-5 for weapon selection
            if (event.key >= '1' && event.key <= '5') {
                const weapons = ['pistol', 'shotgun', 'chaingun', 'plasma', 'bfg'];
                const weaponIndex = parseInt(event.key) - 1;
                if (weaponIndex < weapons.length) {
                    switchWeapon(weapons[weaponIndex]);
                }
            }
        });

        // Add function to draw pickups
        function drawPickups() {
            if (!gameState.pickups || gameState.pickups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.pickups.forEach(pickup => {
                // Calculate pickup position relative to player
                const dx = pickup.x - gameState.player.x;
                const dy = pickup.y - gameState.player.y;
                
                // Calculate angle to pickup
                let pickupAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (pickupAngle - gameState.player.angle > Math.PI) pickupAngle -= 2 * Math.PI;
                while (pickupAngle - gameState.player.angle < -Math.PI) pickupAngle += 2 * Math.PI;
                
                // Calculate pickup distance
                const pickupDist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if pickup is in field of view
                if (Math.abs(pickupAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate pickup size based on distance
                    const pickupSize = Math.min(height / 3, 3000 / pickupDist);
                    
                    // Calculate screen position
                    const angleToCenter = pickupAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Add floating animation
                    const floatAmount = Math.sin(Date.now() / 300) * 10;
                    
                    // Draw pickup based on type
                    ctx.save();
                    
                    if (pickup.type === 'weapon') {
                        // Weapon pickup
                        ctx.fillStyle = '#00ff00';  // Green glow
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 15;
                        
                        // Draw weapon icon
                        ctx.beginPath();
                        ctx.arc(screenX, screenY + floatAmount, pickupSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw weapon name
                        ctx.font = `${Math.max(12, pickupSize / 4)}px Arial`;
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.fillText(pickup.weapon.toUpperCase(), screenX, screenY + floatAmount + pickupSize / 2 + 20);
                    } else if (pickup.type === 'ammo') {
                        // Ammo pickup
                        ctx.fillStyle = '#ffff00';  // Yellow glow
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 15;
                        
                        // Draw ammo box
                        ctx.fillRect(screenX - pickupSize / 3, screenY + floatAmount - pickupSize / 3, pickupSize / 1.5, pickupSize / 1.5);
                        
                        // Draw ammo type
                        ctx.font = `${Math.max(12, pickupSize / 4)}px Arial`;
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.fillText(pickup.ammo_type.toUpperCase(), screenX, screenY + floatAmount + pickupSize / 2 + 20);
                    }
                    
                    ctx.restore();
                }
            });
        }

        // Setup spawn fish button
        function setupSpawnFishButton() {
            console.log("Setting up spawn fish button");
            const spawnFishBtn = document.getElementById('spawnFishBtn');
            
            spawnFishBtn.addEventListener('click', function() {
                console.log("Spawn fish button clicked");
                
                // Send request to spawn fish
                fetch('/spawn-fish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count: 3 })  // Spawn 3 fish at once
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Fish spawned:", data);
                    updateGame(data);
                })
                .catch(error => {
                    console.error('Error spawning fish:', error);
                });
            });
        }

        // Initialize everything
        function initializeGame() {
            setupControls();
            setupToggleViewButton();
            setupSpawnFishButton();
            resetGame();
            console.log("Game initialized");
        }

        // Call the initialization function
        initializeGame();

        // Define MAP if it doesn't exist
        if (typeof MAP === 'undefined') {
            debug("Defining MAP variable");
            window.MAP = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
        }
        
        // Define player if it doesn't exist
        if (typeof player === 'undefined') {
            debug("Defining player variable");
            window.player = {
                fov: Math.PI / 3,  // 60 degrees field of view
                depth: 16          // Maximum render distance
            };
        }

        // Load textures for Doom-style rendering
        const textures = {
            walls: {
                default: new Image(),
                tech: new Image(),
                slime: new Image(),
                blood: new Image(),
                metal: new Image()
            },
            sprites: {
                imp: new Image(),
                demon: new Image(),
                cacodemon: new Image(),
                baron: new Image(),
                pistol: new Image(),
                shotgun: new Image(),
                chaingun: new Image(),
                plasma: new Image(),
                bfg: new Image()
            },
            items: {
                health: new Image(),
                armor: new Image(),
                ammo: new Image(),
                weapon: new Image()
            },
            hud: {
                face: new Image(),
                numbers: new Image()
            }
        };

        // Set texture sources
        textures.walls.default.src = 'https://i.imgur.com/Yj4uLI2.png'; // Red brick wall
        textures.walls.tech.src = 'https://i.imgur.com/2wRjdML.png';    // Tech wall
        textures.walls.slime.src = 'https://i.imgur.com/kPHW2HK.png';   // Green slime wall
        textures.walls.blood.src = 'https://i.imgur.com/BGrwZL4.png';   // Blood wall
        textures.walls.metal.src = 'https://i.imgur.com/cBGRCh5.png';   // Metal wall
        
        // Enemy sprites
        textures.sprites.imp.src = 'https://i.imgur.com/OFrCLbL.png';
        textures.sprites.demon.src = 'https://i.imgur.com/jLxBSP0.png';
        textures.sprites.cacodemon.src = 'https://i.imgur.com/lDRbBdW.png';
        textures.sprites.baron.src = 'https://i.imgur.com/MF6Ym7S.png';
        
        // Weapon sprites
        textures.sprites.pistol.src = 'https://i.imgur.com/r9PXvoL.png';
        textures.sprites.shotgun.src = 'https://i.imgur.com/V3yY9VU.png';
        textures.sprites.chaingun.src = 'https://i.imgur.com/JQ2Ccpf.png';
        textures.sprites.plasma.src = 'https://i.imgur.com/RmkfVoM.png';
        textures.sprites.bfg.src = 'https://i.imgur.com/9Bn6sHD.png';
        
        // Item sprites
        textures.items.health.src = 'https://i.imgur.com/E8F8nzr.png';
        textures.items.armor.src = 'https://i.imgur.com/LRpuPbm.png';
        textures.items.ammo.src = 'https://i.imgur.com/xkXsnE2.png';
        textures.items.weapon.src = 'https://i.imgur.com/V4dLpRK.png';
        
        // HUD elements
        textures.hud.face.src = 'https://i.imgur.com/XM0Tupf.png';
        textures.hud.numbers.src = 'https://i.imgur.com/P2uKVKS.png';
        
        let texturesLoaded = false;
        let texturesLoadingPromises = [];
        
        // Create a promise for each texture
        for (let category in textures) {
            for (let key in textures[category]) {
                const img = textures[category][key];
                const promise = new Promise((resolve) => {
                    img.onload = resolve;
                });
                texturesLoadingPromises.push(promise);
            }
        }
        
        // When all textures are loaded
        Promise.all(texturesLoadingPromises).then(() => {
            texturesLoaded = true;
            console.log("All textures loaded successfully");
            
            // Redraw the game with textures
            drawGame();
        });

        // Add a function to draw a Doom-style HUD
        function drawDoomHUD() {
            try {
                debug("Drawing Doom-style HUD");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw HUD background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, height - 40, width, 40);
                
                // Draw health
                ctx.font = '16px "Press Start 2P", cursive';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'left';
                ctx.fillText("HEALTH", 10, height - 15);
                
                // Draw health numbers
                ctx.fillStyle = '#ffffff';
                ctx.fillText(gameState.player.health, 100, height - 15);
                
                // Draw ammo for current weapon
                ctx.fillStyle = '#ffff00';
                ctx.textAlign = 'right';
                
                const currentWeapon = gameState.player.current_weapon || 'pistol';
                const ammoType = WEAPONS[currentWeapon].ammo_type;
                const ammoCount = gameState.player.ammo[ammoType];
                
                ctx.fillText("AMMO", width - 80, height - 15);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(ammoCount, width - 10, height - 15);
                
                // Draw armor if player has any
                if (gameState.player.armor > 0) {
                    ctx.fillStyle = '#00aaff';
                    ctx.textAlign = 'center';
                    ctx.fillText("ARMOR: " + gameState.player.armor, width / 2, height - 15);
                }
                
                debug("HUD drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawDoomHUD:", error);
                console.error(error.stack);
                return false;
            }
        }
    </script>
</body>
</html>