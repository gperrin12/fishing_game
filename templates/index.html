<!DOCTYPE html>
<html>
<head>
    <title>Fishing Shooter 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2a2a2a;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: none;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 10px auto;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #555;
            background-color: #000;
            border-radius: 10px;
        }

        #score {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #4CAF50;
            text-align: center;
        }

        #ammo {
            font-size: 1.2rem;
            margin: 5px 0;
            color: #ff9800;
            text-align: center;
        }

        #gameOver {
            display: none;
            color: #cc0000;
            font-size: 1.2rem;
            margin: 10px 0;
            text-align: center;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin: 20px auto;
        }

        .control-btn {
            padding: 15px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 10px;
            touch-action: manipulation;
        }

        #shootBtn {
            grid-column: 2;
            background-color: #cc0000;
        }

        #resetBtn {
            grid-column: 1 / span 3;
            background-color: #4CAF50;
        }

        #forwardBtn {
            grid-column: 2;
            grid-row: 1;
        }

        #backwardBtn {
            grid-column: 2;
            grid-row: 3;
        }

        #leftBtn {
            grid-column: 1;
            grid-row: 2;
        }

        #rightBtn {
            grid-column: 3;
            grid-row: 2;
        }

        #shootBtn {
            grid-column: 2;
            grid-row: 2;
        }

        @media (max-width: 600px) {
            .control-btn {
                padding: 12px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="ammo">Lure Power: 1.0x</div>
    <div id="gameOver">Game Over! The fish have taken over the lake!</div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="controls">
        <button class="control-btn" id="forwardBtn">‚Üë</button>
        <button class="control-btn" id="leftBtn">‚Üê</button>
        <button class="control-btn" id="shootBtn">üé£</button>
        <button class="control-btn" id="rightBtn">‚Üí</button>
        <button class="control-btn" id="backwardBtn">‚Üì</button>
        <button class="control-btn" id="resetBtn">New Game</button>
        <button class="control-btn" id="toggleViewBtn" style="background-color: #9c27b0;">Toggle View</button>
    </div>

    <audio id="splashSound" src="https://assets.mixkit.co/sfx/preview/mixkit-water-splash-1295.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>

    <script>
        console.log("Script starting...");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameInterval;
        
        // Game state
        let player = {
            x: 2,
            y: 2,
            angle: 0,
            fov: 60 * Math.PI / 180
        };
        
        // Fish types with properties
        const FISH_TYPES = {
            'bluegill': { color: '#4169E1', speed: 0.03, health: 1, damage: 1, points: 10 },
            'bass': { color: '#006400', speed: 0.02, health: 2, damage: 2, points: 20 },
            'pike': { color: '#8B4513', speed: 0.04, health: 1, damage: 3, points: 15 },
            'muskie': { color: '#DC143C', speed: 0.01, health: 4, damage: 5, points: 30 }
        };
        
        // Map definition (1 = wall, 0 = empty)
        const MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        
        // Game state
        let gameState = {
            player: {
                x: 2,
                y: 2,
                angle: 0,
                lures: 10,
                lure_power: 1.0,
                lure_speed: 1.0,
                power_ups: []
            },
            fish: [],
            score: 0,
            game_over: false,
            power_ups: []
        };

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = (containerWidth * 0.75) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function castRay(angle) {
            try {
                // Ray casting algorithm to find walls
                const rayDirX = Math.cos(angle);
                const rayDirY = Math.sin(angle);
                
                let mapX = Math.floor(gameState.player.x);
                let mapY = Math.floor(gameState.player.y);
                
                // Calculate distance to next x or y grid line
                let deltaDistX = Math.abs(1 / (rayDirX || 0.00001));
                let deltaDistY = Math.abs(1 / (rayDirY || 0.00001));
                
                let stepX, stepY;
                let sideDistX, sideDistY;
                
                // Calculate step and initial sideDist
                if (rayDirX < 0) {
                    stepX = -1;
                    sideDistX = (gameState.player.x - mapX) * deltaDistX;
                } else {
                    stepX = 1;
                    sideDistX = (mapX + 1.0 - gameState.player.x) * deltaDistX;
                }
                
                if (rayDirY < 0) {
                    stepY = -1;
                    sideDistY = (gameState.player.y - mapY) * deltaDistY;
                } else {
                    stepY = 1;
                    sideDistY = (mapY + 1.0 - gameState.player.y) * deltaDistY;
                }
                
                // Perform DDA
                let hit = 0;
                let side = 0;
                let maxDistance = 20; // Maximum ray distance
                let distance = 0;
                
                while (hit === 0 && distance < maxDistance) {
                    // Jump to next map square
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        side = 0;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        side = 1;
                    }
                    
                    distance += 1;
                    
                    // Check if ray has hit a wall
                    if (mapY < 0 || mapX < 0 || mapY >= MAP.length || mapX >= MAP[0].length) {
                        hit = 1; // Hit map boundary
                    } else if (MAP[mapY][mapX] > 0) {
                        hit = 1; // Hit wall
                    }
                }
                
                // Calculate distance projected on camera direction
                let perpWallDist;
                if (side === 0) {
                    perpWallDist = (mapX - gameState.player.x + (1 - stepX) / 2) / rayDirX;
                } else {
                    perpWallDist = (mapY - gameState.player.y + (1 - stepY) / 2) / rayDirY;
                }
                
                // Ensure we don't return infinity or NaN
                perpWallDist = Math.max(0.1, perpWallDist || 0.1);
                
                return {
                    distance: perpWallDist,
                    side: side,
                    mapX: mapX,
                    mapY: mapY,
                    stepX: stepX,
                    stepY: stepY
                };
            } catch (error) {
                console.error("Error in castRay:", error);
                // Return a default value to prevent crashes
                return {
                    distance: 5,
                    side: 0,
                    mapX: 0,
                    mapY: 0,
                    stepX: 1,
                    stepY: 1
                };
            }
        }

        function drawWalls() {
            console.log("Drawing walls...");
            const width = canvas.width;
            const height = canvas.height;
            
            // Draw sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height/2);
            skyGradient.addColorStop(0, "#87CEEB");
            skyGradient.addColorStop(1, "#E0F7FA");
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height/2);
            
            // Draw ground/water
            const groundGradient = ctx.createLinearGradient(0, height/2, 0, height);
            groundGradient.addColorStop(0, "#0077be");
            groundGradient.addColorStop(1, "#005a87");
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, height/2, width, height/2);
            
            // Draw walls
            const numRays = width;
            const rayWidth = width / numRays;
            
            for (let x = 0; x < numRays; x++) {
                // Calculate ray angle
                const rayAngle = gameState.player.angle - player.fov/2 + (x / numRays) * player.fov;
                
                // Cast ray
                const result = castRay(rayAngle);
                
                if (!result) {
                    console.error("Ray casting failed for angle:", rayAngle);
                    continue;
                }
                
                // Calculate wall height
                const wallDist = result.distance;
                const wallHeight = Math.min(height, height / wallDist * 2);
                
                // Draw wall
                const wallY = (height - wallHeight) / 2;
                
                // Determine wall color based on orientation
                let wallColor;
                if (result.side === 0) {
                    wallColor = result.stepX > 0 ? "#228B22" : "#006400"; // Green for X walls
                } else {
                    wallColor = result.stepY > 0 ? "#8B4513" : "#A0522D"; // Brown for Y walls
                }
                
                ctx.fillStyle = wallColor;
                ctx.fillRect(x * rayWidth, wallY, rayWidth + 1, wallHeight);
            }
            
            console.log("Walls drawn");
        }

        function drawFish() {
            if (!gameState.fish || gameState.fish.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Sort fish by distance (furthest first for proper rendering)
            gameState.fish.sort((a, b) => {
                const distA = Math.pow(a.x - gameState.player.x, 2) + Math.pow(a.y - gameState.player.y, 2);
                const distB = Math.pow(b.x - gameState.player.x, 2) + Math.pow(b.y - gameState.player.y, 2);
                return distB - distA;
            });
            
            // Draw each fish as a sprite in the 3D world
            gameState.fish.forEach(fish => {
                // Calculate fish position relative to player
                const dx = fish.x - gameState.player.x;
                const dy = fish.y - gameState.player.y;
                
                // Calculate angle to fish
                let fishAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (fishAngle - gameState.player.angle > Math.PI) fishAngle -= 2 * Math.PI;
                while (fishAngle - gameState.player.angle < -Math.PI) fishAngle += 2 * Math.PI;
                
                // Calculate fish distance
                const fishDist = Math.sqrt(dx * dx + dy * dy);
                
                // Play splash sound occasionally for nearby fish
                if (fishDist < 10 && Math.random() < 0.005) {
                    const splashSound = document.getElementById('splashSound');
                    splashSound.volume = Math.min(1.0, 8 / fishDist) * 0.4;
                    splashSound.currentTime = 0;
                    splashSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Check if fish is in field of view
                if (Math.abs(fishAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate fish size based on distance
                    const fishSize = Math.min(height / 2.5, 6000 / fishDist);
                    
                    // Calculate screen position
                    const angleToCenter = fishAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Calculate vertical position based on distance (closer fish appear lower)
                    // This creates the illusion that fish are swimming at eye level
                    const screenY = height / 2 + (fishDist < 3 ? 20 : 0);
                    
                    // Draw fish shadow on floor
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(screenX, height / 2 + fishSize/2, fishSize / 3, fishSize / 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw fish with sprite-like appearance
                    ctx.save();
                    
                    // Add "bobbing" motion to simulate swimming
                    const bobAmount = Math.sin(Date.now() / 300 + fish.x * 10) * 5;
                    
                    // Determine if fish is facing left or right relative to player
                    const fishFacingRight = Math.cos(fish.direction - fishAngle) > 0;
                    
                    // Draw fish body with glow effect
                    ctx.shadowColor = FISH_TYPES[fish.type].color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = FISH_TYPES[fish.type].color;
                    
                    // Draw fish body
                    ctx.beginPath();
                    if (fishFacingRight) {
                        // Fish facing right
                        ctx.ellipse(screenX, screenY + bobAmount, fishSize / 2, fishSize / 3, 0, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw fish eye
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(screenX + fishSize / 4, screenY + bobAmount - fishSize / 8, fishSize / 15, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw fish tail
                        ctx.fillStyle = FISH_TYPES[fish.type].color;
                        ctx.beginPath();
                        ctx.moveTo(screenX - fishSize / 3, screenY + bobAmount);
                        ctx.lineTo(screenX - fishSize / 1.5, screenY + bobAmount - fishSize / 4);
                        ctx.lineTo(screenX - fishSize / 1.5, screenY + bobAmount + fishSize / 4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw fins
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + bobAmount - fishSize / 6);
                        ctx.lineTo(screenX + fishSize / 6, screenY + bobAmount - fishSize / 3);
                        ctx.lineTo(screenX - fishSize / 6, screenY + bobAmount - fishSize / 3);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Fish facing left
                        ctx.ellipse(screenX, screenY + bobAmount, fishSize / 2, fishSize / 3, 0, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw fish eye
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(screenX - fishSize / 4, screenY + bobAmount - fishSize / 8, fishSize / 15, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Draw fish tail
                        ctx.fillStyle = FISH_TYPES[fish.type].color;
                        ctx.beginPath();
                        ctx.moveTo(screenX + fishSize / 3, screenY + bobAmount);
                        ctx.lineTo(screenX + fishSize / 1.5, screenY + bobAmount - fishSize / 4);
                        ctx.lineTo(screenX + fishSize / 1.5, screenY + bobAmount + fishSize / 4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw fins
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + bobAmount - fishSize / 6);
                        ctx.lineTo(screenX - fishSize / 6, screenY + bobAmount - fishSize / 3);
                        ctx.lineTo(screenX + fishSize / 6, screenY + bobAmount - fishSize / 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Draw mouth
                    ctx.fillStyle = '#600';
                    ctx.beginPath();
                    if (fishFacingRight) {
                        ctx.arc(screenX + fishSize / 2, screenY + bobAmount, fishSize / 10, -Math.PI/4, Math.PI/4);
                    } else {
                        ctx.arc(screenX - fishSize / 2, screenY + bobAmount, fishSize / 10, Math.PI*3/4, Math.PI*5/4);
                    }
                    ctx.fill();
                    
                    // Add health bar for fish
                    const healthPercent = fish.health / FISH_TYPES[fish.type].health;
                    const barWidth = fishSize * 0.8;
                    const barHeight = fishSize / 15;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(screenX - barWidth/2, screenY + bobAmount - fishSize/2 - barHeight*2, barWidth, barHeight);
                    
                    ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(screenX - barWidth/2, screenY + bobAmount - fishSize/2 - barHeight*2, barWidth * healthPercent, barHeight);
                    
                    ctx.restore();
                }
            });
        }

        function drawWeapon() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Draw fishing rod
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(width / 2 - 5, height - 100, 10, 100);
            
            // Draw reel
            ctx.fillStyle = '#C0C0C0';
            ctx.beginPath();
            ctx.arc(width / 2, height - 70, 15, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 2, height - 100);
            ctx.lineTo(width / 2, height - 150);
            ctx.stroke();
            
            // Draw lure
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(width / 2, height - 150, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawBullets() {
            if (!gameState.player.bullets) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.bullets.forEach(bullet => {
                // Calculate bullet position relative to player
                const dx = bullet.x - gameState.player.x;
                const dy = bullet.y - gameState.player.y;
                
                // Calculate angle to bullet
                let bulletAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (bulletAngle - gameState.player.angle > Math.PI) bulletAngle -= 2 * Math.PI;
                while (bulletAngle - gameState.player.angle < -Math.PI) bulletAngle += 2 * Math.PI;
                
                // Check if bullet is in field of view
                if (Math.abs(bulletAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate bullet distance
                    const bulletDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate bullet size based on distance
                    const bulletSize = Math.min(10, 200 / bulletDist);
                    
                    // Calculate screen position
                    const angleToCenter = bulletAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw bullet
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bulletSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Add a glow effect
                    ctx.shadowColor = '#FF6666';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bulletSize * 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        function drawExplosions() {
            if (!gameState.player.explosions) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.explosions.forEach((explosion, index) => {
                // Play hit sound for new explosions
                if (explosion.time === 10 && index === 0) {
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.3;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Calculate explosion position relative to player
                const dx = explosion.x - gameState.player.x;
                const dy = explosion.y - gameState.player.y;
                
                // Calculate angle to explosion
                let explosionAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (explosionAngle - gameState.player.angle > Math.PI) explosionAngle -= 2 * Math.PI;
                while (explosionAngle - gameState.player.angle < -Math.PI) explosionAngle += 2 * Math.PI;
                
                // Check if explosion is in field of view
                if (Math.abs(explosionAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate explosion distance
                    const explosionDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate explosion size based on distance and time
                    const timeRatio = explosion.time / 10; // 10 is max time
                    const explosionSize = Math.min(50, 1000 / explosionDist) * (1 - timeRatio * 0.5);
                    
                    // Calculate screen position
                    const angleToCenter = explosionAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, explosionSize
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, explosionSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function drawPowerUps() {
            if (!gameState.power_ups || gameState.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.power_ups.forEach(powerUp => {
                // Calculate power-up position relative to player
                const dx = powerUp.x - gameState.player.x;
                const dy = powerUp.y - gameState.player.y;
                
                // Calculate angle to power-up
                let powerUpAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (powerUpAngle - gameState.player.angle > Math.PI) powerUpAngle -= 2 * Math.PI;
                while (powerUpAngle - gameState.player.angle < -Math.PI) powerUpAngle += 2 * Math.PI;
                
                // Calculate power-up distance
                const powerUpDist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if power-up is in field of view
                if (Math.abs(powerUpAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate power-up size based on distance
                    const powerUpSize = Math.min(height / 10, 2000 / powerUpDist);
                    
                    // Calculate screen position
                    const angleToCenter = powerUpAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Add bobbing motion
                    const bobAmount = Math.sin(Date.now() / 500 + powerUp.bob_offset) * 10;
                    const screenY = height / 2 + bobAmount;
                    
                    // Draw power-up with glow effect
                    ctx.save();
                    ctx.shadowColor = powerUp.color;
                    ctx.shadowBlur = 15;
                    
                    // Draw rotating cube or diamond shape
                    ctx.translate(screenX, screenY);
                    ctx.rotate(powerUp.rotation);
                    
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    if (powerUp.type === 'power') {
                        // Draw a star for power
                        const spikes = 5;
                        const outerRadius = powerUpSize;
                        const innerRadius = powerUpSize / 2;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                    } else if (powerUp.type === 'speed') {
                        // Draw a lightning bolt for speed
                        ctx.moveTo(-powerUpSize/2, -powerUpSize);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-powerUpSize/2, powerUpSize);
                        ctx.lineTo(powerUpSize/2, 0);
                        ctx.lineTo(0, -powerUpSize/2);
                        
                    } else if (powerUp.type === 'spread') {
                        // Draw a triple dot pattern for spread shot
                        ctx.arc(-powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(0, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
        }

        function drawPowerUpHUD() {
            if (!gameState.player.power_ups || gameState.player.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const iconSize = 30;
            const padding = 10;
            
            // Draw active power-ups in the corner
            gameState.player.power_ups.forEach((powerUp, index) => {
                const x = width - iconSize - padding;
                const y = padding + (iconSize + padding) * index;
                
                // Calculate remaining time
                const elapsed = Date.now() / 1000 - powerUp.start_time;
                const remaining = Math.max(0, powerUp.duration - elapsed);
                const timeRatio = remaining / powerUp.duration;
                
                // Draw power-up icon
                ctx.fillStyle = powerUp.type === 'power' ? '#ff0000' : 
                                powerUp.type === 'speed' ? '#00ff00' : '#0000ff';
                ctx.fillRect(x, y, iconSize, iconSize);
                
                // Draw timer bar
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y + iconSize + 2, iconSize * timeRatio, 3);
                
                // Draw icon symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.type === 'power' ? 'P' : 
                    powerUp.type === 'speed' ? 'S' : '3',
                    x + iconSize / 2, y + iconSize / 2
                );
            });
        }

        let use3DView = true;

        document.getElementById('toggleViewBtn').addEventListener('click', () => {
            use3DView = !use3DView;
            drawGame();
        });

        function drawGame() {
            try {
                console.log("Drawing game...");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (use3DView) {
                    try {
                        drawWalls();
                    } catch (error) {
                        console.error("Error in 3D view:", error);
                        drawFallbackView();
                        return;
                    }
                } else {
                    drawFallbackView();
                    return;
                }
                
                if (gameState.power_ups) {
                    console.log("Drawing power-ups:", gameState.power_ups.length);
                    try {
                        drawPowerUps();
                    } catch (error) {
                        console.error("Error drawing power-ups:", error);
                    }
                }
                
                if (gameState.player && gameState.player.bullets) {
                    console.log("Drawing bullets:", gameState.player.bullets.length);
                    try {
                        drawBullets();
                    } catch (error) {
                        console.error("Error drawing bullets:", error);
                    }
                }
                
                if (gameState.fish) {
                    console.log("Drawing fish:", gameState.fish.length);
                    try {
                        drawFish();
                    } catch (error) {
                        console.error("Error drawing fish:", error);
                    }
                }
                
                if (gameState.player && gameState.player.explosions) {
                    console.log("Drawing explosions:", gameState.player.explosions.length);
                    try {
                        drawExplosions();
                    } catch (error) {
                        console.error("Error drawing explosions:", error);
                    }
                }
                
                try {
                    drawWeapon();
                } catch (error) {
                    console.error("Error drawing weapon:", error);
                }
                
                if (gameState.player && gameState.player.power_ups) {
                    console.log("Drawing power-up HUD:", gameState.player.power_ups.length);
                    try {
                        drawPowerUpHUD();
                    } catch (error) {
                        console.error("Error drawing power-up HUD:", error);
                    }
                }
                
                // Update UI
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                document.getElementById('ammo').textContent = `Lure Power: ${gameState.player.lure_power.toFixed(1)}x`;
                
                if (gameState.game_over) {
                    document.getElementById('gameOver').style.display = 'block';
                    clearInterval(gameInterval);
                }
                
                console.log("Game drawn successfully");
            } catch (error) {
                console.error("Error drawing game:", error);
                drawFallbackView();
            }
        }

        function updateGame(newState) {
            console.log("Received game state:", newState);
            if (!newState) {
                console.error("Game state is null or undefined!");
                return;
            }
            
            gameState = newState;
            
            // Check if critical properties exist
            if (!gameState.player) {
                console.error("Player object missing in game state!");
                return;
            }
            
            if (!gameState.fish) {
                console.error("Fish array missing in game state!");
                return;
            }
            
            if (!gameState.power_ups) {
                console.error("Power-ups array missing in game state!");
                return;
            }
            
            console.log("Drawing game with state:", gameState);
            drawGame();
        }

        function setupControls() {
            // Touch controls
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('LEFT');
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('RIGHT');
            });
            document.getElementById('forwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('FORWARD');
            });
            document.getElementById('backwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('BACKWARD');
            });
            document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });
            
            // Mouse controls
            document.getElementById('leftBtn').addEventListener('mousedown', () => move('LEFT'));
            document.getElementById('rightBtn').addEventListener('mousedown', () => move('RIGHT'));
            document.getElementById('forwardBtn').addEventListener('mousedown', () => move('FORWARD'));
            document.getElementById('backwardBtn').addEventListener('mousedown', () => move('BACKWARD'));
            document.getElementById('shootBtn').addEventListener('click', shoot);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // Keyboard controls with continuous movement
            let keyState = {};
            
            document.addEventListener('keydown', (e) => {
                keyState[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
            });

            document.addEventListener('keyup', (e) => {
                keyState[e.key] = false;
            });

            // Continuous movement check
            setInterval(() => {
                if (keyState['ArrowLeft']) move('LEFT');
                if (keyState['ArrowRight']) move('RIGHT');
                if (keyState['ArrowUp']) move('FORWARD');
                if (keyState['ArrowDown']) move('BACKWARD');
            }, 50);
            
            // Mouse look
            canvas.addEventListener('mousemove', (e) => {
                if (e.buttons === 1) { // Left mouse button held down
                    const movementX = e.movementX || 0;
                    move('LOOK', movementX / 100);
                }
            });
        }

        function move(direction, amount = 1) {
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ direction: direction, amount: amount })
            })
            .then(response => response.json())
            .then(updateGame)
            .catch(error => console.error('Error:', error));
        }

        function shoot() {
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shoot: true })
            })
            .then(response => response.json())
            .then(updateGame)
            .catch(error => console.error('Error:', error));
        }

        function resetGame() {
            console.log("Resetting game...");
            document.getElementById('gameOver').style.display = 'none';
            
            fetch('/reset', { method: 'POST' })
                .then(response => {
                    console.log("Reset response received");
                    return response.json();
                })
                .then(data => {
                    console.log("Reset data:", data);
                    updateGame(data);
                    
                    // Set up the game interval
                    console.log("Setting up game interval");
                    clearInterval(gameInterval);
                    gameInterval = setInterval(() => {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        })
                        .then(response => response.json())
                        .then(updateGame)
                        .catch(error => console.error('Error in game interval:', error));
                    }, 50);
                })
                .catch(error => console.error('Error resetting game:', error));
        }

        function drawFallbackView() {
            console.log("Drawing fallback view");
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw a simple background
            ctx.fillStyle = '#87CEEB';  // Sky blue
            ctx.fillRect(0, 0, width, height/2);
            
            ctx.fillStyle = '#0077be';  // Water blue
            ctx.fillRect(0, height/2, width, height/2);
            
            // Draw a simple grid to represent the map
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            
            const cellSize = 20;
            for (let y = 0; y < MAP.length; y++) {
                for (let x = 0; x < MAP[0].length; x++) {
                    const screenX = x * cellSize;
                    const screenY = y * cellSize;
                    
                    if (MAP[y][x] === 1) {
                        ctx.fillStyle = '#006400';  // Dark green for walls
                        ctx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                    
                    ctx.strokeRect(screenX, screenY, cellSize, cellSize);
                }
            }
            
            // Draw player position
            if (gameState && gameState.player) {
                const playerX = gameState.player.x * cellSize;
                const playerY = gameState.player.y * cellSize;
                
                ctx.fillStyle = '#ff0000';  // Red for player
                ctx.beginPath();
                ctx.arc(playerX, playerY, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw direction line
                const dirX = playerX + Math.cos(gameState.player.angle) * 10;
                const dirY = playerY + Math.sin(gameState.player.angle) * 10;
                
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(playerX, playerY);
                ctx.lineTo(dirX, dirY);
                ctx.stroke();
            }
            
            // Draw fish positions
            if (gameState && gameState.fish) {
                gameState.fish.forEach(fish => {
                    const fishX = fish.x * cellSize;
                    const fishY = fish.y * cellSize;
                    
                    ctx.fillStyle = FISH_TYPES[fish.type].color;
                    ctx.beginPath();
                    ctx.arc(fishX, fishY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            // Draw a message
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Fallback View - Check Console for Errors', width/2, 30);
        }

        setupControls();
        resetGame();
    </script>
</body>
</html>