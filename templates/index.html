<!DOCTYPE html>
<html>
<head>
    <title>Doom II Fishing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            touch-action: none;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 10px auto;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #555;
            background-color: #000;
            border-radius: 10px;
        }

        #score {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #ff0000;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #ammo {
            font-size: 1.2rem;
            margin: 5px 0;
            color: #ff9900;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }

        #gameOver {
            display: none;
            color: #ff0000;
            font-size: 2rem;
            text-shadow: 3px 3px 0px #000;
            margin: 10px 0;
            text-align: center;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin: 20px auto;
        }

        .control-btn {
            padding: 15px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #8b0000;
            color: white;
            border: 2px solid #ff0000;
            border-radius: 10px;
            touch-action: manipulation;
        }

        #shootBtn {
            grid-column: 2;
            background-color: #ff0000;
        }

        #resetBtn {
            grid-column: 1 / span 3;
            background-color: #4CAF50;
        }

        #forwardBtn {
            grid-column: 2;
            grid-row: 1;
        }

        #backwardBtn {
            grid-column: 2;
            grid-row: 3;
        }

        #leftBtn {
            grid-column: 1;
            grid-row: 2;
        }

        #rightBtn {
            grid-column: 3;
            grid-row: 2;
        }

        #shootBtn {
            grid-column: 2;
            grid-row: 2;
        }

        @media (max-width: 600px) {
            .control-btn {
                padding: 12px;
                font-size: 1rem;
            }
        }

        /* Add weapon selection UI */
        #weaponSelector {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .weapon-btn {
            padding: 5px 10px;
            margin: 0 5px;
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
        }
        
        .weapon-btn.active {
            background-color: #ff0000;
            border-color: #ff6666;
        }
        
        /* Add health bar */
        #healthBar {
            width: 100%;
            max-width: 300px;
            height: 20px;
            background-color: #333;
            margin: 10px auto;
            border: 2px solid #666;
        }
        
        #healthFill {
            height: 100%;
            background-color: #ff0000;
            width: 100%;
        }
        
        /* Add ammo display */
        #ammoDisplay {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        .ammo-type {
            margin: 0 10px;
            color: #ff9900;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="ammo">Health: 100</div>
    <div id="gameOver">Game Over! The mutant fish have defeated you!</div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="controls">
        <button class="control-btn" id="forwardBtn">‚Üë</button>
        <button class="control-btn" id="leftBtn">‚Üê</button>
        <button class="control-btn" id="shootBtn">üé£</button>
        <button class="control-btn" id="rightBtn">‚Üí</button>
        <button class="control-btn" id="backwardBtn">‚Üì</button>
        <button class="control-btn" id="resetBtn">New Game</button>
        <button class="control-btn" id="toggleViewBtn" style="background-color: #9c27b0;">Toggle View</button>
        <button class="control-btn" id="spawnFishBtn" style="background-color: #2196F3;">Spawn Fish</button>
        <button class="control-btn" id="debugBtn" style="background-color: #673AB7;">Debug</button>
        <button class="control-btn" id="directHitBtn" style="background-color: #E91E63;">Direct Hit</button>
    </div>

    <div id="healthBar"><div id="healthFill"></div></div>
    <div id="ammoDisplay">
        <div class="ammo-type">FLIES: <span id="bulletAmmo">50</span></div>
        <div class="ammo-type">SPINNERS: <span id="shellAmmo">0</span></div>
        <div class="ammo-type">CRANKBAITS: <span id="cellAmmo">0</span></div>
    </div>

    <div id="weaponSelector">
        <button class="weapon-btn active" data-weapon="basic">BASIC ROD</button>
        <button class="weapon-btn" data-weapon="spinning">SPINNING ROD</button>
        <button class="weapon-btn" data-weapon="baitcaster">BAITCASTER</button>
        <button class="weapon-btn" data-weapon="trolling">TROLLING ROD</button>
        <button class="weapon-btn" data-weapon="pro_rod">PRO ROD</button>
    </div>

    <audio id="splashSound" src="https://assets.mixkit.co/sfx/preview/mixkit-water-splash-1295.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>

    <script>
        // Debug mode
        const DEBUG = true;
        
        // Function to log debug messages
        function debug(message) {
            if (DEBUG) {
                console.log(`[DEBUG] ${message}`);
            }
        }
        
        // Verify canvas and context
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error("Could not get 2D context!");
                return;
            }
            
            debug("Canvas and context initialized successfully");
        });

        console.log("Script starting...");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameInterval;
        
        // Game state
        let player = {
            x: 2,
            y: 2,
            angle: 0,
            fov: 60 * Math.PI / 180
        };
        
        // Fish types with properties
        const FISH_TYPES = {
            'bluegill': { color: '#4169E1', speed: 0.03, health: 1, damage: 1, points: 10 },
            'bass': { color: '#006400', speed: 0.02, health: 2, damage: 2, points: 20 },
            'pike': { color: '#8B4513', speed: 0.04, health: 1, damage: 3, points: 15 },
            'muskie': { color: '#DC143C', speed: 0.01, health: 4, damage: 5, points: 30 }
        };
        
        // Map definition (1 = wall, 0 = empty)
        const MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        
        // Game state
        let gameState = {
            player: {
                x: 2,
                y: 2,
                angle: 0,
                lures: 10,
                lure_power: 1.0,
                lure_speed: 1.0,
                power_ups: []
            },
            fish: [],
            score: 0,
            game_over: false,
            power_ups: []
        };

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = (containerWidth * 0.75) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function castRay(angle) {
            try {
                // Ray casting algorithm to find walls
                const rayDirX = Math.cos(angle);
                const rayDirY = Math.sin(angle);
                
                let mapX = Math.floor(gameState.player.x);
                let mapY = Math.floor(gameState.player.y);
                
                // Calculate distance to next x or y grid line
                let deltaDistX = Math.abs(1 / (rayDirX || 0.00001));
                let deltaDistY = Math.abs(1 / (rayDirY || 0.00001));
                
                let stepX, stepY;
                let sideDistX, sideDistY;
                
                // Calculate step and initial sideDist
                if (rayDirX < 0) {
                    stepX = -1;
                    sideDistX = (gameState.player.x - mapX) * deltaDistX;
                } else {
                    stepX = 1;
                    sideDistX = (mapX + 1.0 - gameState.player.x) * deltaDistX;
                }
                
                if (rayDirY < 0) {
                    stepY = -1;
                    sideDistY = (gameState.player.y - mapY) * deltaDistY;
                } else {
                    stepY = 1;
                    sideDistY = (mapY + 1.0 - gameState.player.y) * deltaDistY;
                }
                
                // Perform DDA
                let hit = 0;
                let side = 0;
                let maxDistance = 20; // Maximum ray distance
                let distance = 0;
                
                while (hit === 0 && distance < maxDistance) {
                    // Jump to next map square
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        side = 0;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        side = 1;
                    }
                    
                    distance += 1;
                    
                    // Check if ray has hit a wall
                    if (mapY < 0 || mapX < 0 || mapY >= MAP.length || mapX >= MAP[0].length) {
                        hit = 1; // Hit map boundary
                    } else if (MAP[mapY][mapX] > 0) {
                        hit = 1; // Hit wall
                    }
                }
                
                // Calculate distance projected on camera direction
                let perpWallDist;
                if (side === 0) {
                    perpWallDist = (mapX - gameState.player.x + (1 - stepX) / 2) / rayDirX;
                } else {
                    perpWallDist = (mapY - gameState.player.y + (1 - stepY) / 2) / rayDirY;
                }
                
                // Ensure we don't return infinity or NaN
                perpWallDist = Math.max(0.1, perpWallDist || 0.1);
                
                return {
                    distance: perpWallDist,
                    side: side,
                    mapX: mapX,
                    mapY: mapY,
                    stepX: stepX,
                    stepY: stepY
                };
            } catch (error) {
                console.error("Error in castRay:", error);
                // Return a default value to prevent crashes
                return {
                    distance: 5,
                    side: 0,
                    mapX: 0,
                    mapY: 0,
                    stepX: 1,
                    stepY: 1
                };
            }
        }

        function drawWalls() {
            try {
                debug("Drawing walls");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw sky (dark red for Doom's hellish sky)
                const skyGradient = ctx.createLinearGradient(0, 0, 0, height/2);
                skyGradient.addColorStop(0, "#350000");
                skyGradient.addColorStop(1, "#5a0000");
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, width, height/2);
                
                // Draw floor (dark brown)
                const floorGradient = ctx.createLinearGradient(0, height/2, 0, height);
                floorGradient.addColorStop(0, "#301810");
                floorGradient.addColorStop(1, "#181010");
                ctx.fillStyle = floorGradient;
                ctx.fillRect(0, height/2, width, height/2);
                
                // Draw simple walls if textures aren't loaded
                if (!texturesLoaded) {
                    ctx.fillStyle = "#8b0000";  // Dark red for walls
                    
                    // Draw a simple corridor
                    ctx.fillRect(width*0.1, height*0.25, width*0.8, height*0.05);  // Top wall
                    ctx.fillRect(width*0.1, height*0.7, width*0.8, height*0.05);   // Bottom wall
                    ctx.fillRect(width*0.1, height*0.25, width*0.05, height*0.5);  // Left wall
                    ctx.fillRect(width*0.85, height*0.25, width*0.05, height*0.5); // Right wall
                    
                    debug("Drew simple walls (textures not loaded)");
                    return true;
                }
                
                // Draw the walls with a simpler approach
                for (let x = 0; x < width; x += 4) {  // Step by 4 pixels for better performance
                    // Calculate the ray angle
                    const rayAngle = gameState.player.angle - Math.PI/6 + (x/width) * Math.PI/3;
                    
                    // Cast the ray
                    const result = castRay(rayAngle);
                    
                    if (result.hit) {
                        // Calculate wall height
                        const distance = result.distance * Math.cos(rayAngle - gameState.player.angle); // Fix fisheye effect
                        const wallHeight = Math.min(height, Math.floor(height / distance));
                        
                        // Draw the wall slice
                        const wallTop = Math.floor((height - wallHeight) / 2);
                        
                        // Choose wall texture based on wall type
                        let wallTexture = textures.walls.default;
                        
                        // Draw the wall slice
                        ctx.fillStyle = result.side === 0 ? "#8b0000" : "#6a0000"; // Darker for side walls
                        ctx.fillRect(x, wallTop, 4, wallHeight);
                    }
                }
                
                debug("Walls drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawWalls:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawFish() {
            try {
                debug("Drawing fish (enemies)");
                if (!gameState.fish || gameState.fish.length === 0) {
                    return true;
                }
                
                const width = canvas.width;
                const height = canvas.height;
                const playerX = gameState.player.x;
                const playerY = gameState.player.y;
                const playerAngle = gameState.player.angle;
                
                // Draw each fish
                gameState.fish.forEach(fish => {
                    // Calculate relative position to player
                    const dx = fish.x - playerX;
                    const dy = fish.y - playerY;
                    
                    // Calculate angle to fish
                    let fishAngle = Math.atan2(dy, dx);
                    
                    // Normalize angle difference to [-PI, PI]
                    let angleDiff = fishAngle - playerAngle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Only draw if in view (roughly within player's FOV)
                    if (Math.abs(angleDiff) < Math.PI/3) {
                        // Calculate distance
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Calculate size based on distance
                        const size = Math.min(height/3, height / (distance * 1.5));
                        
                        // Calculate screen position
                        const screenX = width/2 + (angleDiff / (Math.PI/3)) * (width/2);
                        const screenY = height/2;
                        
                        // Draw enemy
                        ctx.fillStyle = "#ff0000";
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, size/2, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Draw health bar
                        const healthPercent = fish.health / 10; // Assuming max health is 10
                        const barWidth = size;
                        const barHeight = size/10;
                        
                        ctx.fillStyle = "#333";
                        ctx.fillRect(screenX - barWidth/2, screenY - size/2 - barHeight*2, barWidth, barHeight);
                        
                        ctx.fillStyle = healthPercent > 0.5 ? "#00ff00" : healthPercent > 0.25 ? "#ffff00" : "#ff0000";
                        ctx.fillRect(screenX - barWidth/2, screenY - size/2 - barHeight*2, barWidth * healthPercent, barHeight);
                    }
                });
                
                debug("Fish drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawFish:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawWeapon() {
            try {
                debug("Drawing fishing rod");
                if (!gameState.player) {
                    return true;
                }
                
                const width = canvas.width;
                const height = canvas.height;
                
                // Get the current rod
                const currentRod = gameState.player.current_rod || 'basic';
                
                // Define rod properties
                const rodProps = {
                    basic: {
                        width: width * 0.3,
                        height: height * 0.3,
                        color: "#8b8b8b"
                    },
                    spinning: {
                        width: width * 0.4,
                        height: height * 0.25,
                        color: "#654321"
                    },
                    baitcaster: {
                        width: width * 0.5,
                        height: height * 0.35,
                        color: "#5a5a5a"
                    },
                    trolling: {
                        width: width * 0.45,
                        height: height * 0.3,
                        color: "#00aaff"
                    },
                    pro_rod: {
                        width: width * 0.6,
                        height: height * 0.4,
                        color: "#00ff00"
                    }
                };
                
                // Get properties for current rod
                const props = rodProps[currentRod] || rodProps.basic;
                
                // Calculate bounce effect
                const bounceY = Math.sin(Date.now() / 150) * 10 * (isMoving ? 1 : 0.2);
                
                // Draw weapon
                ctx.fillStyle = props.color;
                
                // Calculate position
                const weaponX = width / 2;
                const weaponY = height - props.height / 2 + bounceY;
                
                // Draw a simple weapon shape
                ctx.fillRect(
                    weaponX - props.width / 2,
                    weaponY - props.height / 2,
                    props.width,
                    props.height
                );
                
                // Draw rod details
                if (currentRod === 'basic') {
                    // Draw basic rod pole
                    ctx.fillStyle = "#333333";
                    ctx.fillRect(
                        weaponX - props.width / 6,
                        weaponY - props.height / 2 - props.height / 4,
                        props.width / 3,
                        props.height / 3
                    );
                } else if (currentRod === 'spinning') {
                    // Draw spinning rod
                    ctx.fillStyle = "#333333";
                    ctx.fillRect(
                        weaponX - props.width / 4,
                        weaponY - props.height / 2 - props.height / 5,
                        props.width / 2,
                        props.height / 4
                    );
                } else if (currentRod === 'baitcaster') {
                    // Draw baitcaster rod
                    ctx.fillStyle = "#333333";
                    ctx.fillRect(
                        weaponX - props.width / 3,
                        weaponY - props.height / 2 - props.height / 6,
                        props.width / 1.5,
                        props.height / 3
                    );
                } else if (currentRod === 'trolling') {
                    // Draw trolling rod
                    ctx.fillStyle = "#00ffff";
                    ctx.fillRect(
                        weaponX - props.width / 4,
                        weaponY - props.height / 2 - props.height / 4,
                        props.width / 2,
                        props.height / 3
                    );
                } else if (currentRod === 'pro_rod') {
                    // Draw pro rod
                    ctx.fillStyle = "#00ff00";
                    ctx.fillRect(
                        weaponX - props.width / 3,
                        weaponY - props.height / 2 - props.height / 3,
                        props.width / 1.5,
                        props.height / 2
                    );
                }
                
                debug("Weapon drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawWeapon:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawBullets() {
            try {
                debug("Drawing bullets");
                if (!gameState.player || !gameState.player.bullets || gameState.player.bullets.length === 0) {
                    return true;
                }
                
                const width = canvas.width;
                const height = canvas.height;
                const playerX = gameState.player.x;
                const playerY = gameState.player.y;
                const playerAngle = gameState.player.angle;
                
                // Draw each bullet
                gameState.player.bullets.forEach(bullet => {
                    // Calculate relative position to player
                    const dx = bullet.x - playerX;
                    const dy = bullet.y - playerY;
                    
                    // Calculate angle to bullet
                    let bulletAngle = Math.atan2(dy, dx);
                    
                    // Normalize angle difference to [-PI, PI]
                    let angleDiff = bulletAngle - playerAngle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Only draw if in view (roughly within player's FOV)
                    if (Math.abs(angleDiff) < Math.PI/3) {
                        // Calculate distance
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Calculate size based on distance
                        const size = Math.min(20, 40 / distance);
                        
                        // Calculate screen position
                        const screenX = width/2 + (angleDiff / (Math.PI/3)) * (width/2);
                        const screenY = height/2;
                        
                        // Draw bullet
                        ctx.fillStyle = "#ffff00"; // Yellow for bullets
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, size/2, 0, Math.PI*2);
                        ctx.fill();
                    }
                });
                
                debug("Bullets drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawBullets:", error);
                console.error(error.stack);
                return false;
            }
        }

        function drawExplosions() {
            if (!gameState.player || !gameState.player.explosions) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.player.explosions.forEach((explosion, index) => {
                // Play hit sound for new explosions
                if (explosion.time === 10 && index === 0) {
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.3;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                }
                
                // Calculate explosion position relative to player
                const dx = explosion.x - gameState.player.x;
                const dy = explosion.y - gameState.player.y;
                
                // Calculate angle to explosion
                let explosionAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (explosionAngle - gameState.player.angle > Math.PI) explosionAngle -= 2 * Math.PI;
                while (explosionAngle - gameState.player.angle < -Math.PI) explosionAngle += 2 * Math.PI;
                
                // Check if explosion is in field of view
                if (Math.abs(explosionAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate explosion distance
                    const explosionDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate explosion size based on distance and time
                    const timeRatio = explosion.time / 10; // 10 is max time
                    const explosionSize = Math.min(50, 1000 / explosionDist) * (1 - timeRatio * 0.5);
                    
                    // Calculate screen position
                    const angleToCenter = explosionAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    const screenY = height / 2;
                    
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, explosionSize
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, explosionSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function drawPowerUps() {
            if (!gameState.power_ups || gameState.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            gameState.power_ups.forEach(powerUp => {
                // Calculate power-up position relative to player
                const dx = powerUp.x - gameState.player.x;
                const dy = powerUp.y - gameState.player.y;
                
                // Calculate angle to power-up
                let powerUpAngle = Math.atan2(dy, dx);
                
                // Normalize angles
                while (powerUpAngle - gameState.player.angle > Math.PI) powerUpAngle -= 2 * Math.PI;
                while (powerUpAngle - gameState.player.angle < -Math.PI) powerUpAngle += 2 * Math.PI;
                
                // Calculate power-up distance
                const powerUpDist = Math.sqrt(dx * dx + dy * dy);
                
                // Check if power-up is in field of view
                if (Math.abs(powerUpAngle - gameState.player.angle) < player.fov / 2) {
                    // Calculate power-up size based on distance
                    const powerUpSize = Math.min(height / 10, 2000 / powerUpDist);
                    
                    // Calculate screen position
                    const angleToCenter = powerUpAngle - gameState.player.angle;
                    const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                    
                    // Add bobbing motion
                    const bobAmount = Math.sin(Date.now() / 500 + powerUp.bob_offset) * 10;
                    const screenY = height / 2 + bobAmount;
                    
                    // Draw power-up with glow effect
                    ctx.save();
                    ctx.shadowColor = powerUp.color;
                    ctx.shadowBlur = 15;
                    
                    // Draw rotating cube or diamond shape
                    ctx.translate(screenX, screenY);
                    ctx.rotate(powerUp.rotation);
                    
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    if (powerUp.type === 'power') {
                        // Draw a star for power
                        const spikes = 5;
                        const outerRadius = powerUpSize;
                        const innerRadius = powerUpSize / 2;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                    } else if (powerUp.type === 'speed') {
                        // Draw a lightning bolt for speed
                        ctx.moveTo(-powerUpSize/2, -powerUpSize);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(-powerUpSize/2, powerUpSize);
                        ctx.lineTo(powerUpSize/2, 0);
                        ctx.lineTo(0, -powerUpSize/2);
                        
                    } else if (powerUp.type === 'spread') {
                        // Draw a triple dot pattern for spread shot
                        ctx.arc(-powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(0, 0, powerUpSize/4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.arc(powerUpSize/2, 0, powerUpSize/4, 0, 2 * Math.PI);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
        }

        function drawPowerUpHUD() {
            if (!gameState.player.power_ups || gameState.player.power_ups.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const iconSize = 30;
            const padding = 10;
            
            // Draw active power-ups in the corner
            gameState.player.power_ups.forEach((powerUp, index) => {
                const x = width - iconSize - padding;
                const y = padding + (iconSize + padding) * index;
                
                // Calculate remaining time
                const elapsed = Date.now() / 1000 - powerUp.start_time;
                const remaining = Math.max(0, powerUp.duration - elapsed);
                const timeRatio = remaining / powerUp.duration;
                
                // Draw power-up icon
                ctx.fillStyle = powerUp.type === 'power' ? '#ff0000' : 
                                powerUp.type === 'speed' ? '#00ff00' : '#0000ff';
                ctx.fillRect(x, y, iconSize, iconSize);
                
                // Draw timer bar
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y + iconSize + 2, iconSize * timeRatio, 3);
                
                // Draw icon symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.type === 'power' ? 'P' : 
                    powerUp.type === 'speed' ? 'S' : '3',
                    x + iconSize / 2, y + iconSize / 2
                );
            });
        }

        // Global variable to track view mode
        let use3DView = true;

        // Function to toggle between 3D and 2D views
        function toggleViewSimple() {
            debug("Toggle view button clicked");
            use3DView = !use3DView;
            
            const toggleBtn = document.getElementById('toggleViewBtn');
            if (toggleBtn) {
                toggleBtn.textContent = use3DView ? 'Switch to 2D' : 'Switch to 3D';
            }
            
            debug(`View set to ${use3DView ? '3D' : '2D'}`);
            drawGame();
        }
        
        // Setup the toggle view button with a simple approach
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('toggleViewBtn');
            if (toggleBtn) {
                debug("Setting up toggle view button");
                toggleBtn.addEventListener('click', toggleViewSimple);
            }
        });

        // Update the drawGame function to properly handle the view mode
        function drawGame() {
            try {
                debug(`Drawing game in ${use3DView ? '3D' : '2D'} mode...`);
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (use3DView) {
                    debug("Drawing 3D view");
                    
                    // Draw basic elements
                    if (!drawWalls()) {
                        throw new Error("Failed to draw walls");
                    }
                    
                    // Draw fish (enemies)
                    if (gameState.fish && gameState.fish.length > 0) {
                        if (!drawFish()) {
                            throw new Error("Failed to draw fish");
                        }
                    }
                    
                    // Draw bullets
                    if (gameState.player && gameState.player.bullets && gameState.player.bullets.length > 0) {
                        if (!drawBullets()) {
                            throw new Error("Failed to draw bullets");
                        }
                    }
                    
                    // Draw pickups
                    if (gameState.pickups && gameState.pickups.length > 0) {
                        if (!drawPickups()) {
                            throw new Error("Failed to draw pickups");
                        }
                    }
                    
                    // Draw weapon
                    if (!drawWeapon()) {
                        throw new Error("Failed to draw weapon");
                    }
                    
                    // Draw Doom-style HUD
                    if (!drawDoomHUD()) {
                        throw new Error("Failed to draw HUD");
                    }
                    
                    // Draw crosshair
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, centerY);
                    ctx.lineTo(centerX + 10, centerY);
                    ctx.moveTo(centerX, centerY - 10);
                    ctx.lineTo(centerX, centerY + 10);
                    ctx.stroke();
                } else {
                    debug("Drawing 2D view");
                    draw2DView();
                }
                
                // Update UI elements
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                
                if (gameState.player && gameState.player.health !== undefined) {
                    document.getElementById('ammo').textContent = `Health: ${gameState.player.health}`;
                }
                
                if (gameState.game_over) {
                    document.getElementById('gameOver').style.display = 'block';
                }
                
                debug("Drawing game completed successfully");
            } catch (error) {
                console.error("Error drawing game:", error);
                console.error(error.stack);
                
                // Draw a simple error message
                ctx.fillStyle = '#ff0000';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Error drawing game', canvas.width / 2, canvas.height / 2);
                ctx.fillText('Check console for details', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        // Add a 2D top-down view function
        function draw2DView() {
            try {
                debug("Drawing 2D view");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw background
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, width, height);
                
                // Draw a simple grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                const gridSize = 20;
                const cellSize = Math.min(width, height) / gridSize;
                
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
                
                // Draw player as a yellow circle with direction
                if (gameState.player) {
                    const playerX = gameState.player.x * cellSize;
                    const playerY = gameState.player.y * cellSize;
                    
                    // Draw player circle
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(playerX, playerY, cellSize/2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw direction line
                    const dirX = Math.cos(gameState.player.angle) * cellSize;
                    const dirY = Math.sin(gameState.player.angle) * cellSize;
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playerX, playerY);
                    ctx.lineTo(playerX + dirX, playerY + dirY);
                    ctx.stroke();
                }
                
                debug("2D view drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in draw2DView:", error);
                console.error(error.stack);
                return false;
            }
        }

        // Helper function to get wall color based on wall type
        function getWallColor(wallType) {
            switch(wallType) {
                case 1: return '#8b0000';  // Dark red for stone walls
                case 2: return '#4682b4';  // Steel blue for tech walls
                case 3: return '#006400';  // Dark green for slime walls
                case 4: return '#8b0000';  // Dark red for blood walls
                case 5: return '#708090';  // Slate gray for metal walls
                default: return '#8b0000';  // Default to dark red
            }
        }

        // Update UI elements
        function updateUI() {
            // Update score
            document.getElementById('score').textContent = `Score: ${gameState.score}`;
            
            // Update health
            if (gameState.player && gameState.player.health !== undefined) {
                document.getElementById('ammo').textContent = `Health: ${gameState.player.health}`;
                
                // Update health bar
                const healthPercent = gameState.player.health / 100;
                document.getElementById('healthFill').style.width = `${healthPercent * 100}%`;
            }
            
            // Update ammo display
            if (gameState.player && gameState.player.ammo) {
                document.getElementById('bulletAmmo').textContent = gameState.player.ammo.bullets || 0;
                document.getElementById('shellAmmo').textContent = gameState.player.ammo.shells || 0;
                document.getElementById('cellAmmo').textContent = gameState.player.ammo.cells || 0;
            }
            
            // Check for game over
            if (gameState.game_over) {
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function showHitIndicator(x, y, damage) {
            // Create a floating damage indicator
            const indicator = document.createElement('div');
            indicator.textContent = `-${damage}`;
            indicator.style.position = 'absolute';
            indicator.style.color = '#ff0000';
            indicator.style.fontWeight = 'bold';
            indicator.style.fontSize = '24px';
            indicator.style.textShadow = '2px 2px 0 #000';
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            indicator.style.pointerEvents = 'none';
            indicator.style.zIndex = '1000';
            
            document.body.appendChild(indicator);
            
            // Animate the indicator
            let opacity = 1;
            let posY = y;
            
            const animate = () => {
                opacity -= 0.02;
                posY -= 1;
                
                indicator.style.opacity = opacity;
                indicator.style.top = `${posY}px`;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(indicator);
                }
            };
            
            animate();
        }

        // Update the updateGame function to check for fish health changes
        let previousFishHealth = {};

        function updateGame(newState) {
            console.log("Received game state:", newState);
            
            // Check for fish health changes
            if (newState.fish && gameState && gameState.fish) {
                newState.fish.forEach(fish => {
                    const fishId = `${fish.type}-${fish.x.toFixed(2)}-${fish.y.toFixed(2)}`;
                    
                    if (previousFishHealth[fishId] !== undefined && fish.health < previousFishHealth[fishId]) {
                        // Fish took damage
                        const damage = previousFishHealth[fishId] - fish.health;
                        
                        // Calculate screen position for the fish
                        const dx = fish.x - newState.player.x;
                        const dy = fish.y - newState.player.y;
                        const fishAngle = Math.atan2(dy, dx);
                        
                        if (Math.abs(fishAngle - newState.player.angle) < player.fov / 2) {
                            const width = canvas.width;
                            const height = canvas.height;
                            const angleToCenter = fishAngle - newState.player.angle;
                            const screenX = (angleToCenter / (player.fov / 2)) * (width / 2) + width / 2;
                            const screenY = height / 2;
                            
                            // Show hit indicator
                            showHitIndicator(screenX, screenY, damage);
                            
                            // Play hit sound
                            const hitSound = document.getElementById('hitSound');
                            hitSound.volume = 0.3;
                            hitSound.currentTime = 0;
                            hitSound.play().catch(e => console.log("Audio play failed:", e));
                        }
                    }
                    
                    // Update previous health
                    previousFishHealth[fishId] = fish.health;
                });
            }
            
            gameState = newState;
            drawGame();
        }

        // Track player movement for weapon bounce
        let isMoving = false;
        
        // Update the setupControls function to track movement
        function setupControls() {
            // Touch controls
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('LEFT');
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('RIGHT');
            });
            document.getElementById('forwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('FORWARD');
            });
            document.getElementById('backwardBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                move('BACKWARD');
            });
            document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                shoot();
            });
            
            // Mouse controls
            document.getElementById('leftBtn').addEventListener('mousedown', () => move('LEFT'));
            document.getElementById('rightBtn').addEventListener('mousedown', () => move('RIGHT'));
            document.getElementById('forwardBtn').addEventListener('mousedown', () => move('FORWARD'));
            document.getElementById('backwardBtn').addEventListener('mousedown', () => move('BACKWARD'));
            document.getElementById('shootBtn').addEventListener('click', shoot);
            document.getElementById('resetBtn').addEventListener('click', resetGame);

            // Keyboard controls with continuous movement
            let keyState = {};
            
            document.addEventListener('keydown', (e) => {
                keyState[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
            });

            document.addEventListener('keyup', (e) => {
                keyState[e.key] = false;
            });

            // Continuous movement check
            setInterval(() => {
                if (keyState['ArrowLeft']) move('LEFT');
                if (keyState['ArrowRight']) move('RIGHT');
                if (keyState['ArrowUp']) move('FORWARD');
                if (keyState['ArrowDown']) move('BACKWARD');
            }, 50);
            
            // Mouse look
            canvas.addEventListener('mousemove', (e) => {
                if (e.buttons === 1) { // Left mouse button held down
                    const movementX = e.movementX || 0;
                    move('LOOK', movementX / 100);
                }
            });
            
            // Track movement for weapon bounce
            document.getElementById('forwardBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('backwardBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('leftBtn').addEventListener('mousedown', () => isMoving = true);
            document.getElementById('rightBtn').addEventListener('mousedown', () => isMoving = true);
            
            document.getElementById('forwardBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('backwardBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('leftBtn').addEventListener('mouseup', () => isMoving = false);
            document.getElementById('rightBtn').addEventListener('mouseup', () => isMoving = false);
            
            // Track keyboard movement
            document.addEventListener('keydown', function(event) {
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    isMoving = true;
                }
            });
            
            document.addEventListener('keyup', function(event) {
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    isMoving = false;
                }
            });
        }

        function move(direction, amount = 1) {
            console.log(`Moving: ${direction}, amount: ${amount}`);
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ direction: direction, amount: amount })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Move response received");
                return response.json();
            })
            .then(data => {
                console.log("Move data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in move:', error);
                // Try to update the player position locally for better responsiveness
                if (gameState && gameState.player) {
                    const moveSpeed = 0.1;
                    const rotationSpeed = 0.05;
                    
                    if (direction === 'FORWARD') {
                        const newX = gameState.player.x + Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y + Math.sin(gameState.player.angle) * moveSpeed * amount;
                        // Check if new position is valid (not in a wall)
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'BACKWARD') {
                        const newX = gameState.player.x - Math.cos(gameState.player.angle) * moveSpeed * amount;
                        const newY = gameState.player.y - Math.sin(gameState.player.angle) * moveSpeed * amount;
                        if (newX > 0 && newY > 0 && newX < MAP[0].length && newY < MAP.length) {
                            if (MAP[Math.floor(newY)][Math.floor(newX)] === 0) {
                                gameState.player.x = newX;
                                gameState.player.y = newY;
                            }
                        }
                    } else if (direction === 'LEFT') {
                        gameState.player.angle -= rotationSpeed * amount;
                    } else if (direction === 'RIGHT') {
                        gameState.player.angle += rotationSpeed * amount;
                    } else if (direction === 'LOOK') {
                        gameState.player.angle += rotationSpeed * amount;
                    }
                    
                    drawGame();
                }
            });
        }

        function shoot() {
            console.log("Shooting!");
            
            fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shoot: true })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log("Shoot response received");
                return response.json();
            })
            .then(data => {
                console.log("Shoot data received:", data);
                updateGame(data);
            })
            .catch(error => {
                console.error('Error in shoot:', error);
                
                // Create a local bullet if server request fails
                if (gameState && gameState.player) {
                    if (!gameState.player.bullets) {
                        gameState.player.bullets = [];
                    }
                    
                    // Add a new bullet
                    gameState.player.bullets.push({
                        x: gameState.player.x,
                        y: gameState.player.y,
                        angle: gameState.player.angle,
                        speed: 0.2 * (gameState.player.lure_speed || 1.0),
                        distance: 0,
                        max_distance: 10,
                        active: true
                    });
                    
                    // Play shoot sound
                    const hitSound = document.getElementById('hitSound');
                    hitSound.volume = 0.2;
                    hitSound.currentTime = 0;
                    hitSound.play().catch(e => console.log("Audio play failed:", e));
                    
                    drawGame();
                }
            });
        }

        function resetGame() {
            console.log("Resetting game...");
            document.getElementById('gameOver').style.display = 'none';
            
            fetch('/reset', { method: 'POST' })
                .then(response => {
                    console.log("Reset response received");
                    return response.json();
                })
                .then(data => {
                    console.log("Reset data:", data);
                    updateGame(data);
                    
                    // Set up the game interval
                    console.log("Setting up game interval");
                    clearInterval(gameInterval);
                    gameInterval = setInterval(() => {
                        fetch('/move', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        })
                        .then(response => response.json())
                        .then(updateGame)
                        .catch(error => console.error('Error in game interval:', error));
                    }, 50);
                })
                .catch(error => console.error('Error resetting game:', error));
        }

        function drawCrosshair() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Check if any fish is in the crosshair
            let fishInCrosshair = false;
            
            if (gameState.fish) {
                gameState.fish.forEach(fish => {
                    // Calculate fish position relative to player
                    const dx = fish.x - gameState.player.x;
                    const dy = fish.y - gameState.player.y;
                    
                    // Calculate angle to fish
                    let fishAngle = Math.atan2(dy, dx);
                    
                    // Normalize angles
                    while (fishAngle - gameState.player.angle > Math.PI) fishAngle -= 2 * Math.PI;
                    while (fishAngle - gameState.player.angle < -Math.PI) fishAngle += 2 * Math.PI;
                    
                    // Calculate fish distance
                    const fishDist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if fish is in center of view (crosshair)
                    if (Math.abs(fishAngle - gameState.player.angle) < 0.05 && fishDist < 10) {
                        fishInCrosshair = true;
                    }
                });
            }
            
            // Draw crosshair (red if fish in crosshair, white otherwise)
            ctx.strokeStyle = fishInCrosshair ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2);
            ctx.lineTo(width/2 + 10, height/2);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 10);
            ctx.lineTo(width/2, height/2 + 10);
            ctx.stroke();
            
            // Circle
            ctx.beginPath();
            ctx.arc(width/2, height/2, 5, 0, 2 * Math.PI);
            ctx.stroke();
            
            // If fish in crosshair, add a "target locked" indicator
            if (fishInCrosshair) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(width/2, height/2, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('TARGET LOCKED', width/2, height/2 + 30);
            }
        }

        document.getElementById('debugBtn').addEventListener('click', debugGame);

        function debugGame() {
            console.log("Debug info:");
            console.log("Player:", gameState.player);
            console.log("Fish:", gameState.fish);
            console.log("Bullets:", gameState.player.bullets);
            console.log("Power-ups:", gameState.power_ups);
            
            // Test shooting directly at a fish if any exist
            if (gameState.fish && gameState.fish.length > 0) {
                const fish = gameState.fish[0];
                const dx = fish.x - gameState.player.x;
                const dy = fish.y - gameState.player.y;
                
                // Calculate angle to fish
                const fishAngle = Math.atan2(dy, dx);
                
                // Update player angle to face fish
                gameState.player.angle = fishAngle;
                
                // Shoot at fish
                console.log("Aiming at fish:", fish);
                console.log("Angle to fish:", fishAngle);
                
                fetch('/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        direction: 'LOOK', 
                        amount: (fishAngle - gameState.player.angle) / 0.05,
                        shoot: true 
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Shot at fish, new state:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in debug shoot:', error));
            } else {
                console.log("No fish to target");
            }
        }

        document.getElementById('directHitBtn').addEventListener('click', directHit);

        function directHit() {
            console.log("Attempting direct hit on fish");
            
            if (gameState.fish && gameState.fish.length > 0) {
                fetch('/hit-fish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        index: 0,  // Hit the first fish
                        damage: 1  // Apply 1 damage
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Direct hit response:", data);
                    updateGame(data);
                })
                .catch(error => console.error('Error in direct hit:', error));
            } else {
                console.log("No fish to hit");
            }
        }

        // Add weapon switching function
        function switchWeapon(rodName) {
            if (!gameState.player.rods.includes(rodName)) {
                console.log(`Don't have rod: ${rodName}`);
                return;
            }
            
            console.log(`Switching to rod: ${rodName}`);
            
            fetch('/switch-rod', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rod: rodName })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Rod switched:", data);
                updateGame(data);
                
                // Update rod button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === rodName) {
                        btn.classList.add('active');
                    }
                });
            })
            .catch(error => {
                console.error('Error switching rod:', error);
                
                // Update locally if server request fails
                gameState.player.current_rod = rodName;
                drawGame();
                
                // Update rod button UI
                document.querySelectorAll('.weapon-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.weapon === rodName) {
                        btn.classList.add('active');
                    }
                });
            });
        }

        // Add event listeners for weapon buttons
        document.querySelectorAll('.weapon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchWeapon(btn.dataset.weapon);
            });
        });

        // Add keyboard shortcuts for rod switching
        document.addEventListener('keydown', function(event) {
            // Number keys 1-5 for rod selection
            if (event.key >= '1' && event.key <= '5') {
                const rods = ['basic', 'spinning', 'baitcaster', 'trolling', 'pro_rod'];
                const rodIndex = parseInt(event.key) - 1;
                if (rodIndex < rods.length) {
                    switchWeapon(rods[rodIndex]);
                }
            }
        });

        // Add function to draw pickups
        function drawPickups() {
            try {
                debug("Drawing pickups");
                if (!gameState.pickups || gameState.pickups.length === 0) {
                    return true;
                }
                
                const width = canvas.width;
                const height = canvas.height;
                const playerX = gameState.player.x;
                const playerY = gameState.player.y;
                const playerAngle = gameState.player.angle;
                
                // Draw each pickup
                gameState.pickups.forEach(pickup => {
                    // Calculate relative position to player
                    const dx = pickup.x - playerX;
                    const dy = pickup.y - playerY;
                    
                    // Calculate angle to pickup
                    let pickupAngle = Math.atan2(dy, dx);
                    
                    // Normalize angle difference to [-PI, PI]
                    let angleDiff = pickupAngle - playerAngle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Only draw if in view (roughly within player's FOV)
                    if (Math.abs(angleDiff) < Math.PI/3) {
                        // Calculate distance
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Calculate size based on distance
                        const size = Math.min(height/4, height / (distance * 2));
                        
                        // Calculate screen position
                        const screenX = width/2 + (angleDiff / (Math.PI/3)) * (width/2);
                        const screenY = height/2 + Math.sin(Date.now() / 300) * 10; // Floating effect
                        
                        // Draw pickup based on type
                        if (pickup.type === 'rod') {
                            ctx.fillStyle = "#00ff00"; // Green for rods
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size/2, 0, Math.PI*2);
                            ctx.fill();
                            
                            // Draw label
                            ctx.fillStyle = "#ffffff";
                            ctx.font = `${Math.max(12, size/4)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(pickup.rod.toUpperCase(), screenX, screenY + size/2 + 20);
                        } else if (pickup.type === 'tackle') {
                            ctx.fillStyle = "#ffff00"; // Yellow for tackle
                            ctx.fillRect(screenX - size/3, screenY - size/3, size/1.5, size/1.5);
                            
                            // Draw label
                            ctx.fillStyle = "#ffffff";
                            ctx.font = `${Math.max(12, size/4)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(pickup.tackle_type.toUpperCase(), screenX, screenY + size/2 + 20);
                        } else if (pickup.type === 'health') {
                            ctx.fillStyle = "#ff0000"; // Red for health
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size/2, 0, Math.PI*2);
                            ctx.fill();
                            
                            // Draw cross
                            ctx.strokeStyle = "#ffffff";
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY - size/4);
                            ctx.lineTo(screenX, screenY + size/4);
                            ctx.moveTo(screenX - size/4, screenY);
                            ctx.lineTo(screenX + size/4, screenY);
                            ctx.stroke();
                        }
                    }
                });
                
                debug("Pickups drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawPickups:", error);
                console.error(error.stack);
                return false;
            }
        }

        // Setup spawn fish button
        function setupSpawnFishButton() {
            console.log("Setting up spawn fish button");
            const spawnFishBtn = document.getElementById('spawnFishBtn');
            
            spawnFishBtn.addEventListener('click', function() {
                console.log("Spawn fish button clicked");
                
                // Send request to spawn fish
                fetch('/spawn-fish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count: 3 })  // Spawn 3 fish at once
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Fish spawned:", data);
                    updateGame(data);
                })
                .catch(error => {
                    console.error('Error spawning fish:', error);
                });
            });
        }

        // Initialize everything
        function initializeGame() {
            setupControls();
            setupToggleViewButton();
            setupSpawnFishButton();
            resetGame();
            console.log("Game initialized");
        }

        // Call the initialization function
        initializeGame();

        // Define MAP if it doesn't exist
        if (typeof MAP === 'undefined') {
            debug("Defining MAP variable");
            window.MAP = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
        }
        
        // Define player if it doesn't exist
        if (typeof player === 'undefined') {
            debug("Defining player variable");
            window.player = {
                fov: Math.PI / 3,  // 60 degrees field of view
                depth: 16          // Maximum render distance
            };
        }

        // Define initial game state if needed
        if (!gameState || !gameState.player) {
            gameState = {
                player: {
                    x: 2,
                    y: 2,
                    angle: 0,
                    health: 100,
                    armor: 0,
                    current_rod: 'basic',
                    rods: ['basic'],
                    tackle_box: {
                        flies: 50,
                        spinners: 0,
                        crankbaits: 0
                    },
                    rod_cooldown: 0,
                    casts: [],
                    lures: 10,
                    lure_power: 1.0,
                    lure_speed: 1.0,
                    casting_speed: 1.0
                },
                fish: [],
                score: 0,
                game_over: false
            };
        }

        // Load textures for Doom-style rendering
        const textures = {
            walls: {
                default: new Image(),
                tech: new Image(),
                slime: new Image(),
                blood: new Image(),
                metal: new Image()
            },
            sprites: {
                imp: new Image(),
                demon: new Image(),
                cacodemon: new Image(),
                baron: new Image(),
                pistol: new Image(),
                shotgun: new Image(),
                chaingun: new Image(),
                plasma: new Image(),
                bfg: new Image()
            },
            items: {
                health: new Image(),
                armor: new Image(),
                ammo: new Image(),
                weapon: new Image()
            },
            hud: {
                face: new Image(),
                numbers: new Image()
            }
        };

        // Set texture sources
        textures.walls.default.src = 'https://i.imgur.com/Yj4uLI2.png'; // Red brick wall
        textures.walls.tech.src = 'https://i.imgur.com/2wRjdML.png';    // Tech wall
        textures.walls.slime.src = 'https://i.imgur.com/kPHW2HK.png';   // Green slime wall
        textures.walls.blood.src = 'https://i.imgur.com/BGrwZL4.png';   // Blood wall
        textures.walls.metal.src = 'https://i.imgur.com/cBGRCh5.png';   // Metal wall
        
        // Enemy sprites
        textures.sprites.imp.src = 'https://i.imgur.com/OFrCLbL.png';
        textures.sprites.demon.src = 'https://i.imgur.com/jLxBSP0.png';
        textures.sprites.cacodemon.src = 'https://i.imgur.com/lDRbBdW.png';
        textures.sprites.baron.src = 'https://i.imgur.com/MF6Ym7S.png';
        
        // Weapon sprites
        textures.sprites.pistol.src = 'https://i.imgur.com/r9PXvoL.png';
        textures.sprites.shotgun.src = 'https://i.imgur.com/V3yY9VU.png';
        textures.sprites.chaingun.src = 'https://i.imgur.com/JQ2Ccpf.png';
        textures.sprites.plasma.src = 'https://i.imgur.com/RmkfVoM.png';
        textures.sprites.bfg.src = 'https://i.imgur.com/9Bn6sHD.png';
        
        // Item sprites
        textures.items.health.src = 'https://i.imgur.com/E8F8nzr.png';
        textures.items.armor.src = 'https://i.imgur.com/LRpuPbm.png';
        textures.items.ammo.src = 'https://i.imgur.com/xkXsnE2.png';
        textures.items.weapon.src = 'https://i.imgur.com/V4dLpRK.png';
        
        // HUD elements
        textures.hud.face.src = 'https://i.imgur.com/XM0Tupf.png';
        textures.hud.numbers.src = 'https://i.imgur.com/P2uKVKS.png';
        
        let texturesLoaded = false;
        let texturesLoadingPromises = [];
        
        // Create a promise for each texture
        for (let category in textures) {
            for (let key in textures[category]) {
                const img = textures[category][key];
                const promise = new Promise((resolve) => {
                    img.onload = resolve;
                });
                texturesLoadingPromises.push(promise);
            }
        }
        
        // When all textures are loaded
        Promise.all(texturesLoadingPromises).then(() => {
            texturesLoaded = true;
            console.log("All textures loaded successfully");
            
            // Redraw the game with textures
            drawGame();
        });

        // Add a function to draw a Doom-style HUD
        function drawDoomHUD() {
            try {
                debug("Drawing Doom-style HUD");
                const width = canvas.width;
                const height = canvas.height;
                
                // Draw HUD background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, height - 40, width, 40);
                
                // Draw health
                ctx.font = '16px "Press Start 2P", cursive';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'left';
                ctx.fillText("HEALTH", 10, height - 15);
                
                // Draw health numbers
                ctx.fillStyle = '#ffffff';
                ctx.fillText(gameState.player.health, 100, height - 15);
                
                // Draw lures for current rod
                ctx.fillStyle = '#ffff00';
                ctx.textAlign = 'right';
                
                // Safely access rod and lure information with fallbacks
                const currentRod = (gameState.player && gameState.player.current_rod) || 'basic';
                const lureType = (window.RODS && RODS[currentRod] && RODS[currentRod].ammo_type) || 'flies';
                const lureCount = (gameState.player && gameState.player.tackle_box && gameState.player.tackle_box[lureType]) || 0;
                
                ctx.fillText("LURES", width - 80, height - 15);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(lureCount, width - 10, height - 15);
                
                // Draw armor if player has any
                if (gameState.player.armor > 0) {
                    ctx.fillStyle = '#00aaff';
                    ctx.textAlign = 'center';
                    ctx.fillText("ARMOR: " + gameState.player.armor, width / 2, height - 15);
                }
                
                debug("HUD drawn successfully");
                return true;
            } catch (error) {
                console.error("Error in drawDoomHUD:", error);
                console.error(error.stack);
                return false;
            }
        }

        // Define RODS if it doesn't exist
        if (typeof RODS === 'undefined') {
            debug("Defining RODS variable");
            window.RODS = {
                'basic': {
                    'damage': 1,
                    'speed': 0.3,
                    'cooldown': 20,
                    'sprite': 'basic_rod',
                    'sound': 'cast',
                    'ammo_type': 'flies'
                },
                'spinning': {
                    'damage': 2,
                    'speed': 0.25,
                    'cooldown': 30,
                    'spread': 3,
                    'casts': 3,
                    'sprite': 'spinning_rod',
                    'sound': 'spinning_cast',
                    'ammo_type': 'spinners'
                },
                'baitcaster': {
                    'damage': 1,
                    'speed': 0.3,
                    'cooldown': 5,
                    'sprite': 'baitcaster',
                    'sound': 'baitcaster_cast',
                    'ammo_type': 'flies'
                },
                'trolling': {
                    'damage': 3,
                    'speed': 0.4,
                    'cooldown': 8,
                    'sprite': 'trolling_rod',
                    'sound': 'trolling_cast',
                    'ammo_type': 'crankbaits'
                },
                'pro_rod': {
                    'damage': 10,
                    'speed': 0.2,
                    'cooldown': 60,
                    'explosion_radius': 3,
                    'sprite': 'pro_rod',
                    'sound': 'pro_cast',
                    'ammo_type': 'crankbaits'
                }
            };
        }
    </script>
</body>
</html>